/ *! jQuery v2.2.4 | (c) Fundação jQuery | jquery.org/license * /
! function (a, b) {"object" == typeof module && "object" == typeof module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a .document) throw new Error ("jQuery requer uma janela com um documento"); return b (a)}: b (a)} ("undefined"! = typeof window? window: this, function (a, b) { var c = [], d = a.document, e = c.slice, f = c.concat, g = c.push, h = c.indexOf, i = {}, j = i.toString, k = i .hasOwnProperty, l = {}, m = "2.2.4", n = function (a, b) {return new n.fn.init (a, b)}, o = / ^ [\ s \ uFEFF \ xA0 ] + | [\ s \ uFEFF \ xA0] + $ / g, p = / ^ - ms - /, q = / - ([\ da-z]) / gi, r = função (a, b) {retorno b.toUpperCase ()}; n.fn = n.prototype = {jquery: m, construtor: n, seletor: "", comprimento: 0, toArray: function () {return e.call (this)}, get: function (a) {return null! = a? 0> a? this [a + this.length]: this [a]: e.call (this)}, pushStack: function (a) {var b = n.merge (this.constructor (), a); retornar b.prevObject = this, b.context = this.context, b}, each: function (a) {return n.each (this, a)}, map: function (a) {return this.pushStack (n.map (this , function (b, c) {return a.call (b, c, b)}))}, slice: function () {return this.pushStack (e.apply (this, arguments))}, primeiro: function ( ) {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (a) {var b = this.length, c = + a + (0> a? b: 0); return this.pushStack (c> = 0 && b> c? [this [c]]: [])}, end: function () {return this.prevObject || this.constructor ()}, pressione: g, classificar: c.sort, splice: c.splice}, n.extend = n.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = arguments.length, j =! 1; for ("boolean" == typeof g && (j = g, g = arguments [h] || {}, h ++), "object" = = typeof g || n.isFunction (g) || (g = {}), h === i && (g = this, h -); i> h; h ++) if (null! = (a = argumentos [h])) para (b em a) c = g [b], d = a [b], g! == d && (j && d && (n.isPlainObject (d) || (e = n.isArray (d)))? (e? (e =! 1, f = c && n.isArray (c)? c: []): f = c && n. isPlainObject (c)? c: {}, g [b] = n.extend (j, f, d)): void 0! == d && (g [b] = d)); return g}, n.extend ({expando: "jQuery" + (m + Math.random ()). substituir (/ \ D / g, ""), isReady:! 0, erro: função (a) {lançar novo Erro (a)}, noop: function () {}, isFunction: function (a) {return "function" === n.type (a)}, isArray: Array.isArray, isWindow: function (a) {return null! = a && a == = a.window}, isNumeric: function (a) {var b = a && a.toString (); return! n.isArray (a) && b-parseFloat (b) +1> = 0}, isPlainObject: function (a) { var b; if ("objeto"! == n.type (a) || a.nodeType || n.isWindow (a)) return! 1; if (a.construtor &&! k.call (a, "construtor" ) &&! k.call (a.constructor.prototype || {}, "isPrototypeOf")) return! 1; para (b em a);return void 0 === b || k.call (a, b)}, isEmptyObject: function (a) {var b; for (b in a) return! 1; return! 0}, digite: function (a) {return null == a? a + "": "object" == typeof a || "function" == typeof a? i [j.call (a)] || "object": typeof a}, globalEval: function (a) {var b, c = eval; a = n.trim (a), a && (1 === a.indexOf ("use estrito")? (b = d.createElement ("script"), b. text = a, d.head.appendChild (b) .parentNode.removeChild (b)): c (a))}, camelCase: function (a) {return a.replace (p, "ms -"). replace ( q, r)}, nodeName: function (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, each: function (a, b) {var c, d = 0 ; if (s (a)) {for (c = a.length; c> d; d ++) if (b.call (a [d], d, a [d]) ===! 1) break} else para (d em a) if (b.call (a [d], d, a [d]) ===! 1) quebrar; retornar a}, cortar: função (a) {return null == a? " ": (a +" "). substituir (o," ")},makeArray: function (a, b) {var c = b || []; return null! = a && (s (Object (a))? n.merge (c, "string" == typeof a? [a]: a): g.call (c, a)), c}, inArray: function (a, b, c) {return null == b? -1: h.call (b, a, c)}, merge: function (a, b) {for (var c = + b.length, d = 0, e = a.length; c> d; d ++) a [e ++] = b [d]; return a.length = e, a}, grep: function (a, b, c) {for (var d, e = [], f = 0, g = a.length, h =! c; g> f; f ++) d =! b ( a [f], f), d! == h && e.push (a [f]); return e}, map: function (a, b, c) {var d, e, g = 0, h = [] ; if (s (a)) para (d = a.length; d> g; g ++) e = b (a [g], g, c), nulo! = e && h.push (e); else for (g em a) e = b (a [g], g, c), nulo! = e && h.push (e); retornar f.apply ([], h)}, guid: 1, proxy: função (a, b ) {var c, d, f; return "string" == typeof b && (c = a [b], b = a, a = c), n.isFunction (a)? (d = e.call (argumentos, 2), f = function () {return a.apply (b || this, d.concat (e.call (argumentos)))}, f.guid = a.guid = a.guid || n.guid ++, f): vazio 0}, agora: Date.now,suporte: l}), "function" == typeof Symbol && (n.fn [Symbol.iterator] = c [Symbol.iterator]), n.each ("Boolean Number String Function Array Date RegExp Object Error Symbol" .split ( ""), função (a, b) {i ["[objeto" + b + "]"] = b.toLowerCase ()}); função s (a) {var b = !! a && "comprimento" em a && a. comprimento, c = n.tipo (a); retornar "função" === c || n.isWindow (a) ?! 1: "matriz" === c || 0 === b || "número" == tipo de b && b> 0 && b-1 em a} var t = função (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "chiar" + 1 * nova data, v = a.documento, w = 0, x = 0, y = ga (), z = ga (), A = ga () , B = função (a, b) {return a === b && (l =! 0), 0}, C = 1 << 31, D = {}. HasOwnProperty, E = [], F = E.pop , G = E. empurrar, H = E. empurrar, I = E.slice, J = função (a, b) {para (var c = 0, d = a.length; d> c; c ++) if (a [c] === b) return c; return-1}, K = "verificado | selecionado | assíncrono | foco automático | reprodução automática | controles | adiar | desativado | oculto | ismap | loop | múltiplo | aberto | somente leitura | necessário | escopo ", L =" [\\ x20 \\ t \\ r \\ n \ \ f] ", M =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", N =" \\ ["+ L +" * ( "+ M +") (?: "+ L +" * ([* ^ $ |! ~]? =) "+ L +" * (?: '((?: \\\\. | [^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + M + ")) |)" + L + "* \\ ] ", O =" :( "+ M +") (?: \\ ((('((?: \\\\. | [^ \\\\']) *) '| \ "((? : \\\\. | [^ \\\\\ "]) *) \") | ((?: \\\\. | [^ \\\\ () [\\]] | "+ N + ") *) |. *) \\) |)", P = novo RegExp (L + "+", "g"), Q = novo RegExp ("^" + L + "+ | ((?: ^ | [ ^ \\\\]) (?: \\\\.) *) "+ L +" + $ "," g "), R = novo RegExp (" ^ "+ L +" *, "+ L +" * " ), S = novo RegExp ("^" + L + "* ([> + ~] |"+ L + ")" + L + "*"), T = novo RegExp ("=" + L + "* ([^ \\] '\"] *?) "+ L +" * \\] "," g " ), U = novo RegExp (O), V = novo RegExp ("^" + M + "$"), W = {ID: novo RegExp ("^ # (" + M + ")"), CLASSE: novo RegExp ( "^ \\. (" + M + ")"), TAG: novo RegExp ("^ (" + M + "| [*])"), ATTR: novo RegExp ("^" + N), PSEUDO: novo RegExp ("^" + O), CHILD: new RegExp ("^ :( apenas | primeiro | último | enésimo | enésimo último) - (filho | do tipo) (?: \\ (" + L + "* (par | ímpar | (([+ -] |) (\\ d *) n |) "+ L +" * (?: ([+ -] |) "+ L +" * (\\ d +) |)) "+ L + "* \\) |)", "i"), bool: new RegExp ("^ (?:" + K + ") $", "i"), needsContext: new RegExp ("^" + L + "* [> + ~] |: (par | ímpar | eq | gt | lt | enésimo | primeiro | último) (?: \\ ("+ L +" * ((?: - \\ d)? \\ d *) "+ L +" * \\) |) (? = [^ -] | $) ","i")}, X = / ^ (?: input | select | textarea | botão) $ / i, Y = / ^ h \ d $ / i, Z = / ^ [^ {] + \ {\ s * \ [nativo \ w /, $ = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, _ = / [+ ~] /, aa = / '| \\ / g, ba = new RegExp ("\\\\ ([\\ da-f] {1,6}" + L + "? | (" + L + ") |.) "," ig "), ca = function (a, b, c) {var d =" 0x "+ b-65536; return d! == d || c? b: 0> d? String.fromCharCode (d +65536): String.fromCharCode (d >> 10 | 55296,1023 & d | 56320)}, da = function () {m ()}; tente {H.apply (E = I.call (v.childNodes), v .childNodes), E [v.childNodes.length] .nodeType} catch (ea) {H = {aplicar: E.length? função (a, b) {G.apply (a, I.call (b))} : função (a, b) {var c = a.length, d = 0; while (a [c ++] = b [d ++]); a.length = c-1}}} função fa (a, b, d , e) {var f, h, j, k, l, o, r, s, w = b && b.ownerDocument, x = b? b.nodeType: 9; if (d = d || [], "string" ! = typeof a ||! a || 1! == x && 9! == x && 11! == x) return d; if (! e && ((b? b.ownerDocument || b: v)! == n && m (b), b = b || n, p)) {if (11! == x && (o = $. exec (a))) if (f = o [ 1]) {if (9 === x) {if (! (J = b.getElementById (f))) return d; if (j.id === f) return d.push (j), d} else if (w && (j = w.getElementById (f)) && t (b, j) && j.id === f) return d.push (j), d} else {if (o [2]) retorna H. apply (d, b.getElementsByTagName (a)), d; if ((f = o [3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply (d, b.getElementsByClassName (f)), d} if (c .qsa &&! A [a + ""] && (! q ||! q.teste (a))) {if (1! == x) w = b, s = a; else if ("objeto"! == b.nodeName.toLowerCase ()) {(k = b.getAttribute ("id"))? k = k.replace (aa, "\\ $ &"): b.setAttribute ("id", k = u) , r = g (a), h = r.length, l = V.test (k)? "#" + k: "[id = '" + k + "']"; enquanto (h -) r [ h] = l + "" + qa (r [h]); s = r.join (","), w = _.test (a) && oa (b.parentNode) || b} se (s) tente {return H.apply (d, w.querySelectorAll (s)), d} catch (y) {} finalmente {k === u && b .removeAttribute ("id")}}} return i (a.replace (Q, "$ 1"), b, d, e)} function ga () {var a = []; function b (c, e) { return a.push (c + "")> d.cacheLength && delete b [a.shift ()], b [c + ""] = e} return b} função ha (a) {return a [u] =! 0, a } função ia (a) {var b = n.createElement ("div"); tente {return !! a (b)} catch (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b) , b = null}} função ja (a, b) {var c = a.split ("|"), e = c.length; while (e -) d.attrHandle [c [e]] = b} função ka (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~ b.sourceIndex || C) - (~ a.sourceIndex || C); if ( d) retornar d; if (c) while (c = c.nextSibling) if (c === b) return-1; retornar a? 1:-1} função la (a) {função de retorno (b) {var c = b.Nome do nó.toLowerCase (); retorno "input" === c && b.type === a}} função ma (a) {função de retorno (b) {var c = b.nodeName.toLowerCase (); return ("input" === c || "button" === c) && b.type === a}} função na (a) {return ha (função (b) {retorno b = + b, ha (função (c, d) {var e, f = a ([], c.comprimento, b), g = f.comprimento; enquanto (g-- ) c [e = f [g]] && (c [e] =! (d [e] = c [e]))})})} função oa (a) {return a && "undefined"! = typeof a .getElementsByTagName && a} c = fa.support = {}, f = fa.isXML = function (a) {var b = a && (a.ownerDocument || a) .documentElement; return b? "HTML"! == b.nodeName :! 1}, m = fa.setDocument = function (a) {var b, e, g = a? A.ownerDocument || a: v; return g! == n && 9 === g.nodeType && g.documentElement? ( n = g, o = n.documentElement, p =! f (n), (e = n.defaultView) && e.top! == e && (e.addEventListener? e.addEventListener ("unload", da,! 1): e.attachEvent && e.attachEvent ("onunload", da)), c.attributes = ia (function (a) {return a.className = "i", ! a.getAttribute ("className")}), c.getElementsByTagName = ia (function (a) {return a.appendChild (n.createComment ("")) ,! a.getElementsByTagName ("*"). length}) , c.getElementsByClassName = Z.test (n.getElementsByClassName), c.getById = ia (function (a) {return o.appendChild (a) .id = u,! n.getElementsByName ||! n.getElementsByName (u) .length}), c.getById? (d.find.ID = function (a, b) {if ("undefined"! = typeof b.getElementById && p) {var c = b.getElementById (a); retornar c? [ c]: []}}, d.filter.ID = função (a) {var b = a.replace (ba, ca); função de retorno (a) {return a.getAttribute ("id") === b }}) :( delete d.find.ID, d.filter.ID = function (a) {var b = a.replace (ba, ca);return function (a) {var c = "undefined"! = typeof a.getAttributeNode && a.getAttributeNode ("id"); return c && c.value === b}}), d.find.TAG = c.getElementsByTagName? function ( a, b) {return "undefined"! = typeof b.getElementsByTagName? b.getElementsByTagName (a): c.qsa? b.querySelectorAll (a): void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); if ("*" === a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); return d} return f}, d.find.CLASS = c.getElementsByClassName && function (a, b) {return "undefined"! = typeof b.getElementsByClassName && p? b.getElementsByClassName (a): void 0}, r = [], q = [], (c.qsa = Z.test (n.querySelectorAll)) && (ia (function (a) {o.appendChild (a) .innerHTML = "<a id='"+u+"'> </ a > <select id = '"+ u +" - \ r \\' msallowcapture = ''> <option selected = ''> </option> </select> ", a.querySelectorAll (" [msallowcapture ^ = ''] "). length && q.push (" [* ^ $] = "+ L +" * ( ?: '' | \ "\") "), a.querySelectorAll (" [selecionado] "). comprimento || q.push (" \\ ["+ L +" * (?: valor | "+ K +") "), a.querySelectorAll (" [id ~ = "+ u +" -] "). comprimento || q.push (" ~ = "), a.querySelectorAll (": verificado "). comprimento || q.push (": verificado"), a.querySelectorAll ("a #" + u + "+ *"). comprimento || q.push (". #. + [+ ~]")}), ia (função (a) { var b = n.createElement ("input"); b.setAttribute ("type", "hidden"), a.appendChild (b) .setAttribute ("name", "D"), a.querySelectorAll ("[name = d] "). comprimento && q.push (" nome "+ L +"* [* ^ $ |! ~]? = "), a.querySelectorAll (": enabled "). length || q.push (": enabled ",": disabled "), a.querySelectorAll (" * ,: x "), q.push (",. *: ")})), (c.matchesSelector = Z.test (s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia (function (a) {c.disconnectedMatch = s.call (a, "div"), s.call (a, "[s! = '']: x"), r.push ( "! =", O)}), q = q.length && new RegExp (q.join ("|")), r = r.length && new RegExp (r.join ("|")), b = Z.test ( o.compareDocumentPosition), t = b || Z.test (o.contains)? function (a, b) {var c = 9 === a.nodeType? a.documentElement: a, d = b && b.parentNode; return a === d ||! (! d || 1! == d.nodeType ||! (c.contains? c.contains (d): a.compareDocumentPosition && 16 & a.compareDocumentPosition (d)))}: function (a ,b) {if (b) while (b = b.parentNode) if (b === a) return! 0; return! 1}, B = b? function (a, b) {if (a === b ) return l =! 0,0; var d =! a.compareDocumentPosition-! b.compareDocumentPosition; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (a) === d? a === n || a.ownerDocument === v && t (v, a)? - 1: b === n || b.ownerDocument === v && t (v, b)? 1: k? J (k, a) -J (k, b): 0: 4 & d? -1: 1)}: função ( a, b) {if (a === b) return l =! 0,0; var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b ]; if (! e ||! f) retorna a === n? -1: b === n? 1: e? -1: f? 1: k? J (k, a) -J (k , b): 0; if (e === f) return ka (a, b); c = a; while (c = c.parentNode) g.unshift (c); c = b; while (c = c .parentNode) h.unshift (c); while (g [d] === h [d]) d ++; retornar d? ka (g [d], h [d]): g [d] === v ? -1: h [d] === v? 1: 0}, n): n}, fa.matches = function (a, b) {return fa (a, null, null, b)}, fa. combinaSeletor = função (a, b) {if ((a.ownerDocument || a)! == n && m (a), b = b.replace (T, "= '$ 1']"), c.matchesSelector && p &&! A [b + ""] && (! r ||! r.test (b)) && (! q ||! q.test (b))) tente {var d = s.call (a, b); if (d || c.disconnectedMatch || a.document && 11! == a .document.nodeType) return d} catch (e) {} return fa (b, n, null, [a]). length> 0}, fa.contains = function (a, b) {return (a.ownerDocument | | a)! == n && m (a), t (a, b)}, fa.attr = function (a, b) {(a.ownerDocument || a)! == n && m (a); var e = d .attrHandle [b.toLowerCase ()], f = e && D.call (d.attrHandle, b.toLowerCase ())? e (a, b,! p): void 0; return void 0! == f? f: c.attributes ||! p? a.getAttribute (b) :( f = a.getAttributeNode (b)) && f.specified? f.value: null}, fa.error = function (a) {throw new Error (" Erro de sintaxe, expressão não reconhecida: "+ a)}, fa.uniqueSort = function (a) {var b, d = [], e = 0, f = 0; if (l =! C.detectDuplicates,k =! c.sortStable && a.slice (0), a.sort (B), l) {while (b = a [f ++]) b === a [f] && (e = d.push (f)) ; enquanto (e -) a.splice (d [e], 1)} return k = null, a}, e = fa.getText = function (a) {var b, c = "", d = 0, f = a.nodeType; if (f) {if (1 === f || 9 === f || 11 === f) {if ("string" == typeof a.textContent) retorna a.textContent ; para (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) return a.nodeValue} else while (b = a [d ++]) c + = e (b); return c}, d = fa.selectors = {cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relativo: {"> ": {dir:" parentNode ", primeiro:! 0}," ": {dir:" parentNode "}," + ": {dir:" previousSibling ", primeiro:! 0}," ~ ": {dir: "previousSibling"}}, preFilter: {ATTR: function (a) {return a [1] = a [1] .replace (ba, ca), a [3] = (a [3] || a [4] || a [5] || ""). substituir (ba, ca), "~ =" === a [2] &&(a [3] = "" + a [3] + ""), a.slice (0,4)}, CRIANÇA: função (a) {return a [1] = a [1] .toLowerCase (), "enésimo" === a [1] .slice (0,3)? (a [3] || fa.error (a [0]), a [4] = + (a [4]? a [5 ] + (a [6] || 1): 2 * ("par" === a [3] || "ímpar" === a [3])), a [5] = + (a [7 ] + a [8] || "ímpar" === a [3])): a [3] && fa.error (a [0]), a}, PSEUDO: função (a) {var b, c = ! a [6] && a [2]; retornar W.CHILD.test (a [0])? null: (a [3]? a [2] = a [4] || a [5] || "" : c && U.test (c) && (b = g (c,! 0)) && (b = c.indexOf (")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c.slice (0, b)), a.slice (0,3))}}, filtro: {TAG: function (a) {var b = a.replace (ba, ca) .toLowerCase (); return "*" === a? function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASSE: função (a) {var b = y [a + ""]; retornar b || (b = novo RegExp ("(^ |"+ L + ")" + a + "(" + L + "| $)")) && y (a, função (a) {return b.test ("string" == typeof a.className && a.className || "undefined"! = typeof a.getAttribute && a.getAttribute ("class") || "")})}, ATTR: function (a, b, c) {return function (d) {var e = fa.attr (d, a); return null == e? "! =" === b: b? (e + = "", "=" === b? e === c: "! =" === b? e! == c: "^ =" === b? c && 0 === e.indexOf (c): "* =" === b? c && e.indexOf (c)> - 1: "$ =" === b? c && e.slice (-c.length) === c: "~ =" === b? ("" + e.replace (P, "") + "") .indexOf (c)> - 1: " | = "=== b? e === c || e.slice (0, c.length + 1) === c +" - ":! 1) :! 0}}, CRIANÇA: função (a, b, c, d, e) {var f = "enésimo"! == a.slice (0,3), g = "último"! == a.slice (-4), h = "do tipo" === b;return 1 === d && 0 === e? function (a) {return !! a.parentNode}: function (b, c, i) {var j, k, l, m, n, o, p = f! == g? "nextSibling": "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase (), s =! i &&! h, t =! 1; if (q) {if (f) { while (p) {m = b; while (m = m [p]) if (h? m.nodeName.toLowerCase () === r: 1 === m.nodeType) return! 1; o = p = "apenas" === a &&! o && "nextSibling"} retorna! 0} if (o = [g? q.firstChild: q.lastChild], g && s) {m = q, l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), j = k [a] || [], n = j [0] === w && j [1], t = n && j [2], m = n && q.childNodes [n]; enquanto (m = ++ n && m && m [p] || (t = n = 0) || o.pop ()) if ( 1 === m.nodeType && ++ t && m === b) {k [a] = [w, n, t]; quebrar}} else if (s && (m = b, l = m [u] || ( m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), j = k [a] || [], n = j [0] == = w && j [1], t = n), t ===! 1) enquanto (m = ++ n && m && m [p] || (t = n = 0) || o.pop ()) if ((h? m.nodeName.toLowerCase () === r: 1 === m.nodeType) && ++ t && (s && (l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), k [a] = [w , t]), m === b)) break; return t- = e, t === d || t% d === 0 && t / d> = 0}}}, PSEUDO: função (a, b ) {var c, e = d.pseudos [a] || d.setFilters [a.toLowerCase ()] || fa.error ("pseudo sem suporte:" + a); retornar e [u]? e (b) : e.length> 1? (c = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ())? ha (função (a, c) {var d, f = e ( a, b), g = f.length; enquanto (g -) d = J (a, f [g]), a [d] =! (c [d] = f [g])}): função (a) {return e (a, 0, c)}): e}}, pseudos: {not: ha (function (a) {var b = [], c = [], d = h (a.replace (Q, "$ 1")); retornar d [u]? Ha (função (a, b, c, e) {var f, g = d (a, nulo, e, []), h = a.length ; enquanto (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): função (a, e, f) {return b [0] = a, d (b, nulo, f, c), b [0] = nulo,! c.pop ()}}), tem:ha (function (a) {return function (b) {return fa (a, b) .length> 0}}), contém: ha (function (a) {return a = a.replace (ba, ca), function (b) {return (b.textContent || b.innerText || e (b)). indexOf (a)> - 1}}), lang: ha (function (a) {return V.test (a || "") || fa.error ("idioma não suportado:" + a), a = a.replace (ba, ca) .toLowerCase (), função (b) {var c; faça if (c = p? b. lang: b.getAttribute ("xml: lang") || b.getAttribute ("lang")) return c = c.toLowerCase (), c === a || 0 === c.indexOf (a + "- "); while ((b = b.parentNode) && 1 === b.nodeType); return! 1}}), target: function (b) {var c = a.location && a.location.hash; return c && c.slice (1) === b.id}, root: function (a) {return a === o}, focus: function (a) {return a === n.activeElement && (! N.hasFocus || n. hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)}, habilitado: function (a) {return a.disabled ===! 1}, desabilitado:function (a) {return a.disabled ===! 0}, verificado: function (a) {var b = a.nodeName.toLowerCase (); return "input" === b && !! a.checked || " opção "=== b && !! a.selected}, selecionada: function (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected ===! 0}, vazio: function (a) {for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType <6) return! 1; return! 0}, pai: função (a) {return! d.pseudos.empty (a)}, cabeçalho: function (a) {return Y.test (a.nodeName)}, input: function (a) {return X.test (a.nodeName)}, botão: function (a) {var b = a.nodeName.toLowerCase ( ); return "input" === b && "button" === a.type || "button" === b}, text: function (a) {var b; return "input" === a.nodeName .toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("type")) || "text" === b.toLowerCase ())}, primeiro:na (função () {retorno [0]}), último: na (função (a, b) {retorno [b-1]}), eq: na (função (a, b, c) {retorno [0> c? c + b: c]}), par: na (função (a, b) {para (var c = 0; b> c; c + = 2) a.push (c); retornar a}), ímpar : na (função (a, b) {para (var c = 1; b> c; c + = 2) a.push (c); retornar a}), lt: na (função (a, b, c) { for (var d = 0> c? c + b: c; - d> = 0;) a.push (d); retornar a}), gt: na (função (a, b, c) {for ( var d = 0> c? c + b: c; ++ d <b;) a.push (d); retornar a})}}, d.pseudos.nth = d.pseudos.eq; para (b em {radio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) d.pseudos [b] = la (b); for (b em {enviar:! 0, redefinir :! 0}) d.pseudos [b] = ma (b); função pa () {} pa.prototype = d.filters = d.pseudos, d.setFilters = new pa, g = fa.tokenize = function ( a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; se (k) retornar b? 0: k.slice (0); h = a, i = [], j = d.preFilter; enquanto (h) {c &&! (e = R.exec (h)) || (e && (h = h.slice (e [0] .comprimento) || h), i.push (f = [])), c =! 1, (e = S.exec (h)) && (c = e.shift (), f.push ({value: c, type: e [0] .replace (Q, "")}), h = h.slice (c.length)); for (g em d.filter) ! (e = W [g] .exec (h)) || j [g] &&! (e = j [g] (e)) || (c = e.shift (), f.push ({valor : c, digite: g, corresponde a: e}), h = h.slice (c.length)); if (! c) break} return b? h.length: h? fa.error (a): z ( a, i) .slice (0)}; função qa (a) {para (var b = 0, c = a.length, d = ""; c> b; b ++) d + = a [b] .valor; retornar d} função ra (a, b, c) {var d = b.dir, e = c && "parentNode" === d, f = x ++; retornar b.first? função (b, c, f) {enquanto (b = b [d]) if (1 === b.nodeType || e) retorna a (b, c, f)}: função (b, c, g) {var h, i, j, k = [w, f]; if (g) {while (b = b [d]) if ((1 === b.nodeType || e) && a (b, c, g)) return! 0} else while ( b = b [d]) if (1 === b.nodeType || e) {if (j = b [u] || (b [u] = {}), i = j [b.uniqueID] | | (j [b.uniqueID] = {}), (h = i [d]) && h [0] === w && h [1] === f) return k [2] = h [2]; if ( i [d] = k, k [2] = a (b, c, g)) return! 0}}} função sa (a) {return a.length>1? Função (b, c, d) {var e = a.length; enquanto (e -) if (! A [e] (b, c, d)) return! 1; return! 0}: a [ 0]} função ta (a, b, c) {para (var d = 0, e = b.length; e> d; d ++) fa (a, b [d], c); retorno c} função ua ( a, b, c, d, e) {for (var f, g = [], h = 0, i = a.length, j = null! = b; i> h; h ++) (f = a [h ]) && (c &&! c (f, d, e) || (g.push (f), j && b.push (h))); return g} função va (a, b, c, d, e, f ) {return d &&! d [u] && (d = va (d)), e &&! e [u] && (e = va (e, f)), ha (função (f, g, h, i) { var j, k, l, m = [], n = [], o = g.length, p = f || ta (b || "*", h.nodeType? [h]: h, []) , q =! a ||! f && b? p: ua (p, m, a, h, i), r = c? e || (f? a: o || d)? []: g: q; if (c && c (q, r, h, i), d) {j = ua (r, n), d (j, [], h, i), k = j.length; enquanto (k -) ( l = j [k]) && (r [n [k]] =! (q [n [k]] = l))} if (f) {if (e || a) {if (e) {j = [], k = r.length; enquanto (k -) (l = r [k]) && j.push (q [k] = l); e (nulo, r = [], j, i)} k = r.length; enquanto (k -) (l = r [k]) && (j = e? J (f, l): m [k])> - 1 && (f [j] =! (g [j] = l))}} else r = ua (r === g? r.splice (o, r.length): r), e? e (nulo, g, r, i): H.apply (g, r)})} função wa (a) {para (var b, c, e, f = a.length, g = d.relative [a [0]. tipo], h = g || d.relative [""], i = g? 1: 0, k = ra (função (a) {return a === b}, h,! 0), l = ra (função (a) {retornar J (b, a)> - 1}, h,! 0), m = [função (a, c, d) {var e =! g && (d || c! == j ) || ((b = c) .nodeType? k (a, c, d): l (a, c, d)); return b = null, e}]; f> i; i ++) if (c = d.relativo [a [i] .tipo]) m = [ra (sa (m), c)]; senão {if (c = d.filtro [a [i] .tipo] .aplicar (nulo, a [ i] .matches), c [u]) {for (e = ++ i; f> e; e ++) if (d.relative [a [e] .type]) break; return va (i> 1 && sa (m ), i> 1 && qa (a.slice (0, i-1) .concat ({value: "" === a [i-2] .type? "*": ""})). replace (Q, "$ 1"), c, e> i && wa (a.slice (i, e)), f> e && wa (a = a.slice (e)), f> e && qa (a))} m.push (c)} return sa (m)} função xa (a, b) {var c = b.length>0, e = a.length> 0, f = função (f, g, h, i, k) {var l, o, q, r = 0, s = "0", t = f && [], u = [], v = j, x = f || e && d.find.TAG ("*", k), y = w + = nulo == v? 1: Math.random () || .1, z = x. comprimento; para (k && (j = g === n || g || k); s! == z && null! = (l = x [s]); s ++) {if (e && l) {o = 0, g || l.ownerDocument === n || (m (l), h =! p); enquanto (q = a [o ++]) if (q (l, g || n, h)) {i.push (l); quebrar} k && (w = y)} c && ((l =! q && l) && r -, f && t.push (l))} if (r + = s, c && s! == r) {o = 0; while (q = b [o ++]) q (t, u, g, h); if (f) {if (r> 0) while (s -) t [s] || u [s] || ( u [s] = F.call (i)); u = ua (u)} H.aplicar (i, u), k &&! f && u.length> 0 && r + b.length> 1 && fa.uniqueSort (i)} return k && (w = y, j = v), t}; return c? ha (f): f} return h = fa.compile = function (a, b) {var c, d = [], e = [], f = A [a + ""]; if (! f) {b || (b = g (a)), c = b.length; enquanto (c -) f = wa (b [c]), f [u]? d.push (f): e.push (f); f = A (a,xa (e, d)), f.seletor = a} retorno f}, i = fa.selecionar = função (a, b, e, f) {var i, j, k, l, m, n = "função "== typeof a && a, o =! f && g (a = n.seletor || a); if (e = e || [], 1 === o.length) {if (j = o [0] = o [0] .slice (0), j.length> 2 && "ID" === (k = j [0]). Type && c.getById && 9 === b.nodeType && p && d.relative [j [1] .type]) { if (b = (d.find.ID (k.matches [0] .replace (ba, ca), b) || []) [0] ,! b) return e; n && (b = b.parentNode) , a = a.slice (j.shift (). value.length)} i = W.needsContext.test (a)? 0: j.length; while (i -) {if (k = j [i] , d.relative [l = k.type]) break; if ((m = d.find [l]) && (f = m (k.matches [0] .replace (ba, ca), _. test ( j [0] .type) && oa (b.parentNode) || b))) {if (j.splice (i, 1), a = f.length && qa (j) ,! a) return H.apply (e, f), e; quebrar}}} return (n || h (a, o)) (f, b,! p, e,! b || _.test (a) && oa (b.parentNode) || b ), e}, c.sortStable = u.split (""). sort (B).join ("") === u, c.detectDuplicates = !! l, m (), c.sortDetached = ia (function (a) {return 1 & a.compareDocumentPosition (n.createElement ("div"))}), ia (function (a) {return a.innerHTML = "<a href='#'> </a>", "#" === a.firstChild.getAttribute ("href")}) || ja (" type | href | height | width ", function (a, b, c) {return c? void 0: a.getAttribute (b," type "=== b.toLowerCase ()? 1: 2)}), c .attributes && ia (function (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("value", ""), "" === a.firstChild.getAttribute ("value")} ) || ja ("valor", função (a, b, c) {return c || "input"! == a.nodeName.toLowerCase ()? void 0: a.defaultValue}), ia (função (a ) {return null == a.getAttribute ("disabled")}) || ja (K, função (a, b, c) {var d;return c? void 0: a [b] ===! 0? b.toLowerCase () :( d = a.getAttributeNode (b)) && d.specified? d.value: null}), fa} (a); n.find = t, n.expr = t.seletores, n.expr [":"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n .isXMLDoc = t.isXML, n.contains = t.contains; var u = function (a, b, c) {var d = [], e = void 0! == c; while ((a = a [b ]) && 9! == a.nodeType) if (1 === a.nodeType) {if (e && n (a) .is (c)) break; d.push (a)} return d}, v = função ( a, b) {for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a); return c}, w = n.expr.match. needsContext, x = / ^ <([\ w -] +) \ s * \ /?> (?: <\ / \ 1> |) $ /, y = / ^. [^: # \ [\., ] * $ /; função z (a, b, c) {if (n.isFunction (b)) return n.grep (a, função (a, d) {return !! b.call (a, d, a )! == c}); if (b.nodeType) return n.grep (a, function (a) {return a === b! == c}); if ("string" == typeof b) { if (y.test (b)) retorna n.filtro (b, a, c); b = n.filtro (b,a)} return n.grep (a, function (a) {return h.call (b, a)> - 1! == c})} n.filter = function (a, b, c) {var d = b [0]; return c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d.nodeType? n.find.matchesSelector (d, a)? [d] : []: n.find.matches (a, n.grep (b, function (a) {return 1 === a.nodeType}))}, n.fn.extend ({find: function (a) { var b, c = this.length, d = [], e = this; if ("string"! = typeof a) return this.pushStack (n (a) .filter (function () {for (b = 0; c> b; b ++) if (n.contains (e [b], this)) return! 0})); for (b = 0; c> b; b ++) n.find (a, e [b], d); return d = this.pushStack (c> 1? n.unique (d): d), d.selector = this.selector? this.selector + "" + a: a, d}, filtro: função (a ) {return this.pushStack (z (this, a || [] ,! 1))}, não: function (a) {return this.pushStack (z (this, a || [] ,! 0))} , é: function (a) {return !! z (this, "string" == typeof a && w.test (a)? n (a): a || [] ,! 1) .length}}); var A , B = / ^ (?:\ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, C = n.fn.init = function (a, b, c) { var e, f; if (! a) retorna isto; if (c = c || A, "string" == typeof a) {if (e = "<" === a [0] && ">" = == a [a.length-1] && a.length> = 3? [null, a, null]: B.exec (a) ,! e ||! e [1] && b) return! b || b. jquery? (b || c) .find (a): this.constructor (b) .find (a); if (e [1]) {if (b = b instância de n? b [0]: b, n .merge (this, n.parseHTML (e [1], b && b.nodeType? b.ownerDocument || b: d,! 0)), x.test (e [1]) && n.isPlainObject (b)) para ( e em b) n.isFunction (this [e])? this [e] (b [e]): this.attr (e, b [e]); retornar este} return f = d.getElementById (e [2 ]), f && f.parentNode && (this.length = 1, this [0] = f), this.context = d, this.selector = a, this} return a.nodeType? (this.context = this [0] = a, this.length = 1, this): n.isFunction (a)? void 0! == c.ready? c.ready (a): a (n) :( void 0! == a.selector && (this .selector = a.seletor, this.context = a.context), n.makeArray (a, this))}; C.prototype = n.fn, A = n (d); var D = / ^ (?: pais | prev (? : Até | Todos)) /, E = {filhos:! 0, conteúdo:! 0, próximo:! 0, anterior:! 0}; n.fn.extend ({tem: função (a) {var b = n (a, this), c = b.length; return this.filter (function () {for (var a = 0; c> a; a ++) if (n.contains (this, b [a])) return! 0})}, mais próximo: function (a, b) {for (var c, d = 0, e = this.length, f = [], g = w.test (a) || "string"! = Typeof a? n (a, b || this.context): 0; e> d; d ++) para (c = this [d]; c && c! == b; c = c.parentNode) if (c.nodeType <11 && (g? g.index (c)> - 1: 1 === c.nodeType && n.find.matchesSelector (c, a))) {f.push (c); break} return this.pushStack (f.length> 1? N.uniqueSort (f): f)}, index: function (a) {return a? "String" == typeof a? H.call (n (a), this [0]): h.call ( this, a.jquery? a [0]: a): this [0] && this [0] .parentNode? this.first (). prevAll (). length: -1}, adicione: function (a,b) {return this.pushStack (n.uniqueSort (n.merge (this.get (), n (a, b))))}, addBack: function (a) {return this.add (null == a? this.prevObject: this.prevObject.filter (a))}}); função F (a, b) {while ((a = a [b]) && 1! == a.nodeType); return a} n.each ({pai: função (a) {var b = a.parentNode; retornar b && 11! == b.nodeType? b: nulo}, pais: função (a) {retorno u (a, "paiNodo")}, pais até: function (a, b, c) {return u (a, "parentNode", c)}, next: function (a) {return F (a, "nextSibling")}, prev: function (a) {return F ( a, "previousSibling")}, nextAll: function (a) {return u (a, "nextSibling")}, prevAll: function (a) {return u (a, "previousSibling")}, nextUntil: function (a, b, c) {return u (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return u (a, "previousSibling", c)}, siblings: function (a) {return v ((a.parentNode || {}). firstChild,a)}, filhos: função (a) {retornar v (a.firstChild)}, conteúdo: função (a) {retornar a.contentDocument || n.merge ([], a.childNodes)}}, função (a , b) {n.fn [a] = função (c, d) {var e = n.map (este, b, c); retornar "Até"! == a.slice (-5) && (d = c), d && "string" == typeof d && (e = n.filter (d, e)), this.length> 1 && (E [a] || n.uniqueSort (e), D.test (a) && e .reverse ()), this.pushStack (e)}}); var G = / \ S + / g; função H (a) {var b = {}; retornar n.each (a.match (G) || [], função (a, c) {b [c] =! 0}), b} n.Chamada de retorno = função (a) {a = "string" == tipo de a? H (a): n.extend ( {}, a); var b, c, d, e, f = [], g = [], h = -1, i = função () {para (e = a.uma vez, d = b =! 0 ; g.length; h = -1) {c = g.shift (); enquanto (++ h <f.length) f [h] .apply (c [0], c [1]) ===! 1 && a.stopOnFalse && (h = f.length, c =! 1)} a.memory || (c =! 1), b =! 1, e && (f = c? []: "")}, J = { adicione: function () {return f && (c &&!b && (h = f.length-1, g.push (c)), função d (b) {n.each (b, função (b, c) {n.isFunction (c)? a.unique && j.has ( c) || ​​f.push (c): c && c.length && "string"! == n.type (c) && d (c)})} (argumentos), c &&! b && i ()), this}, remove: function () {retornar n.each (argumentos, função (a, b) {var c; enquanto ((c = n.inArray (b, f, c))> - 1) f.splice (c, 1), h > = c && h -}), this}, tem: function (a) {return a? n.inArray (a, f)> - 1: f.length> 0}, vazio: function () {return f && (f = []), este}, desabilitar: função () {retorno e = g = [], f = c = "", este}, desabilitado: função () {retorno! f}, bloqueio: função () {retorno e = g = [], c || (f = c = ""), este}, bloqueado: function () {return !! e}, fireWith: function (a, c) {return e || (c = c || [], c = [a, c.slice? c.slice (): c], g.push (c), b || i ()), this}, fire: function () {return j .fireWith (this, argumentos), this}, acionado: function () {return !! d}}; return j}, n.extend ({Adiado: função (a) {var b = [["resolver", "concluído", n.Chamada de retorno ("uma vez na memória"), "resolvido"], ["rejeitar", "falha", n.Chamada de retorno ("uma vez na memória"), "rejeitado"], ["notificar", "progresso", n.Chamada de retorno ("memória")]], c = "pendente", d = {estado: função () {retorno c} , sempre: function () {retornar e.done (argumentos) .fail (argumentos), este}, então: function () {var a = argumentos; retornar n.Deferred (função (c) {n.each (b, função (b, f) {var g = n.isFunction (a [b]) && a [b]; e [f [1]] (função () {var a = g && g.apply (this, argumentos); a && n. isFunction (a.promise)? a.promise (). progress (c.notify) .done (c.resolve) .fail (c.reject): c [f [0] + "With"] (this === d? c.promise (): this, g? [a]: argumentos)})}), a = null}). promessa ()}, promessa: função (a) {return null! = a? n.extend (a, d): d}}, e = {};retornar d.pipe = d.então, n.each (b, função (a, f) {var g = f [2], h = f [3]; d [f [1]] = g.add, h && g .add (function () {c = h}, b [1 ^ a] [2] .disable, b [2] [2] .lock), e [f [0]] = function () {return e [ f [0] + "Com"] (este === e? d: este, argumentos), este}, e [f [0] + "Com"] = g.fireWith}), d.promessa (e) , a && a.call (e, e), e}, quando: function (a) {var b = 0, c = e.call (argumentos), d = c.length, f = 1! == d || a && n .isFunction (a.promise)? d: 0, g = 1 === f? a: n.Deferred (), h = function (a, b, c) {return function (d) {b [a] = isto, c [a] = argumentos.comprimento> 1? e.call (argumentos): d, c === i? g.notifyWith (b, c): - f || g.resolveWith (b, c) }}, i, j, k; if (d> 1) para (i = novo Array (d), j = novo Array (d), k = novo Array (d); d> b; b ++) c [b ] && n.isFunction (c [b] .promissão)? c [b] .promessa (). progresso (h (b, j, i)). concluído (h (b, k, c)). falha (g. rejeitar): - f; retornar f || g.resolveWith (k, c), g.promise ()}}); var I; n.fn.ready = function (a) {return n.ready.promise ( )done (a), this}, n.extend ({isReady:! 1, readyWait: 1, holdReady: function (a) {a? n.readyWait ++: n.ready (! 0)}, ready: function (a) {(a ===! 0? - n.readyWait: n.isReady) || (n.isReady =! 0, a! ==! 0 && - n.readyWait> 0 || (I.resolveWith (d , [n]), n.fn.triggerHandler && (n (d) .triggerHandler ("pronto"), n (d) .off ("pronto"))))}}); função J () {d.removeEventListener ("DOMContentLoaded", J), a.removeEventListener ("load", J), n.ready ()} n.ready.promise = function (b) {return I || (I = n.Deferred (), " complete "=== d.readyState ||" carregando "! == d.readyState &&! d.documentElement.doScroll? a.setTimeout (n.ready) :( d.addEventListener (" DOMContentLoaded ", J), a.addEventListener ("carregar", J))), I.promise (b)}, n.ready.promise (); var K = função (a, b, c, d, e, f, g) {var h = 0 , i = a.length, j = null == c; if ("objeto" === n.tipo (c)) {e =! 0;para (h em c) K (a, b, h, c [h] ,! 0, f, g)} else if (vazio 0! == d && (e =! 0, n.isFunction (d) || (g =! 0), j && (g? (b.call (a, d), b = null) :( j = b, b = function (a, b, c) {return j.call (n (a ), c)})), b)) para (; i> h; h ++) b (a [h], c, g? d: d.call (a [h], h, b (a [h] , c))); return e? a: j? b.call (a): i? b (a [0], c): f}, L = function (a) {return 1 === a.nodeType || 9 === a.nodeType ||! + A.nodeType}; função M () {this.expando = n.expando + M.uid ++} M.uid = 1, M.prototype = {registrar: função ( a, b) {var c = b || {}; retornar a.nodeType? a [this.expando] = c: Object.defineProperty (a, this.expando, {valor: c, gravável:! 0, configurável: ! 0}), a [this.expando]}, cache: function (a) {if (! L (a)) return {}; var b = a [this.expando]; return b || (b = { }, L (a) && (a.nodeType? A [this.expando] = b: Object.defineProperty (a, this.expando, {valor: b, configurável:! 0}))), b}, conjunto: função (a, b, c) {var d, e = this.cache (a); if ("string" == typeof b) e [b] = c; else for (d in b) e [d] = b [d];return e}, get: function (a, b) {return void 0 === b? this.cache (a): a [this.expando] && a [this.expando] [b]}, access: function (a , b, c) {var d; return void 0 === b || b && "string" == typeof b && void 0 === c? (d = this.get (a, b), void 0! == d ? d: this.get (a, n.camelCase (b))) :( this.set (a, b, c), void 0! == c? c: b)}, remove: function (a, b) ) {var c, d, e, f = a [this.expando]; if (void 0! == f) {if (void 0 === b) this.register (a); else {n.isArray ( b)? d = b.concat (b.map (n.camelCase)) :( e = n.camelCase (b), b em f? d = [b, e] :( d = e, d = d em f? [d]: d.match (G) || [])), c = d.comprimento; enquanto (c -) excluir f [d [c]]} (vazio 0 === b || n .isEmptyObject (f)) && (a.nodeType? a [this.expando] = void 0: excluir a [this.expando])}}, hasData: function (a) {var b = a [this.expando]; return void 0! == b &&! n.isEmptyObject (b)}}; var N = novo M, O = novo M, P = / ^ (?: \ {[\ w \ W] * \} | \ [ \ w \ W] * \]) $ /, Q = / [AZ] / g; função R (a, b, c) {var d; if (vazio 0 === c &&1 === a.nodeType) if (d = "data -" + b.replace (Q, "- $ &"). ToLowerCase (), c = a.getAttribute (d), "string" == typeof c ) {tente {c = "true" === c?! 0: "false" === c?! 1: "null" === c? null: + c + "" === c? + c: P.test (c)? N.parseJSON (c): c;
} catch (e) {} O.set (a, b, c)} else c = void 0; retornar c} n.extend ({hasData: function (a) {return O.hasData (a) || N. hasData (a)}, data: function (a, b, c) {return O.access (a, b, c)}, removeData: function (a, b) {O.remove (a, b)}, _ data : function (a, b, c) {return N.access (a, b, c)}, _ removeData: function (a, b) {N.remove (a, b)}}), n.fn.extend ( {dados: função (a, b) {var c, d, e, f = this [0], g = f && f.attributes; if (void 0 === a) {if (this.length && (e = O. get (f), 1 === f.nodeType &&! N.get (f, "hasDataAttrs"))) {c = g.length; while (c -) g [c] && (d = g [c] .name, 0 === d.indexOf ("data -") && (d = n.camelCase (d.slice (5)), R (f, d, e [d]))); N.set ( f, "hasDataAttrs",! 0)} return e} return "object" == typeof a? this.each (function () {O.set (this, a)}): K (this, function (b) { var c, d; if (f && void 0 === b) {if (c = O.get (f, a) || O.get (f, a.replace (Q, "- $ &"). toLowerCase ( )), vazio 0!== c) return c; if (d = n.camelCase (a), c = O.get (f, d), void 0! == c) return c; if (c = R (f, d, void 0), void 0! == c) return c} else d = n.camelCase (a), this.each (function () {var c = O.get (this, d); O.set (this, d) , b), a.indexOf ("-")> - 1 && void 0! == c && O.set (this, a, b)})}, null, b, arguments.length> 1, null,! 0)}, removeData: function (a) {return this.each (function () {O.remove (this, a)})}}), n.extend ({queue: function (a, b, c) {var d; return a? (b = (b || "fx") + "fila", d = N.get (a, b), c && (! d || n.isArray (c)? d = N.acesso (a, b, n.makeArray (c)): d.push (c)), d || []): vazio 0}, desenfileirar: função (a, b) {b = b || "fx"; var c = n.queue (a, b), d = c.length, e = c.shift (), f = n._queueHooks (a, b), g = function () {n.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" === b && c.unshift ("inprogress"), excluir f.stop, e.call (a, g , f)),! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; retornar N.get (a, c) || ​​N.access (a, c, {vazio: n. Callbacks ("memória única"). Add (function () {N.remove (a, [b + "queue", c])})})}}), n.fn.extend ({queue: function (a, b) {var c = 2; return "string"! = typeof a && (b = a, a = "fx", c -), arguments.length <c? n.queue (this [0], a): void 0 === b? this: this.each (function () {var c = n.queue (this, a, b); n._queueHooks (this, a), "fx" === a && "inprogress" ! == c [0] && n.dequeue (this, a)})}, desenfileirar: function (a) {return this.each (function () {n.dequeue (this, a)})}, clearQueue: function (a) {return this.queue (a || "fx", [])}, promessa: function (a, b) {var c, d = 1, e = n.Deferred (), f = this, g = this.length, h = function () {- d || e.resolveWith (f, [f])}; "string"! = typeof a && (b = a, a = void 0), a = a | | "fx"; enquanto (g -) c = N.get (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty.add (h)); return h (), e.promise (b )}}); var S = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, T = novo RegExp ( "^ (?: ([+ -]) = |) (" + S + ") ([az%] *) $", "i"), U = ["Superior", "Direita", "Inferior", "Left"], V = function (a, b) {return a = b || a, "none" === n.css (a, "display") ||! N.contains (a.ownerDocument, a )}; função W (a, b, c, d) {var e, f = 1, g = 20, h = d? function () {return d.cur ()}: function () {return n.css (a, b, "")}, i = h (), j = c && c [3] || (n.cssNumber [b]? "": "px"), k = (n.cssNumber [b] | | "px"! == j && + i) && T.exec (n.css (a, b)); if (k && k [3]! == j) {j = j || k [3], c = c || [], k = + i || 1; faça f = f || ".5", k / = f, n.style (a, b, k + j); enquanto (f! == (f = h () / i) && 1! == f && - g)} return c && (k = + k || + i || 0, e = c [1]? k + (c [1] +1) * c [2]: + c [2], d && (d.unidade = j, d.início = k, d.end = e)), e} var X = / ^ (?: caixa de seleção | rádio) $ / i, Y = / <([\ w: -] +) /, Z = / ^ $ | \ / (?: java | ecma) script / i, $ = {option: [1, "<select multiple = 'multiple'>", "</select>"], thead: [1, "< tabela> "," </table> "], col: [2," <table> <colgroup> "," </colgroup> </table> "], tr: [2," <table> <tbody> "," </tbody> </table> "], td: [3," <table> <tbody> <tr> "," </tr> </tbody> </table> "], _ padrão: [ 0, "", ""]}; $. Optgroup = $. Option, $. Tbody = $. Tfoot = $. Colgroup = $. Caption = $. Thead, $. Th = $. Td; function _ (a , b) {var c = "undefined"! = typeof a.getElementsByTagName? a.getElementsByTagName (b || "*"): "undefined "! = typeof a.querySelectorAll? a.querySelectorAll (b ||" * "): []; return void 0 === b || b && n.nodeName (a, b)? n.merge ([a], c): c} função aa (a, b) {para (var c = 0, d = a.length; d> c; c ++) N.set (a [c], "globalEval",! b || N .get (b [c], "globalEval"))} var ba = / <| & #? \ w +; /; função ca (a, b, c, d, e) {for (var f, g, h , i, j, k, l = b.createDocumentFragment (), m = [], o = 0, p = a.length; p> o; o ++) if (f = a [o], f || 0 = == f) if ("objeto" === n.type (f)) n.merge (m, f.nodeType? [f]: f); else if (ba.test (f)) {g = g || l.appendChild (b.createElement ("div")), h = (Y.exec (f) || ["", ""]) [1] .toLowerCase (), i = $ [h] | | $ ._ default, g.innerHTML = i [1] + n.htmlPrefilter (f) + i [2], k = i [0]; enquanto (k -) g = g.lastChild; n.merge (m , g.childNodes), g = l.firstChild, g.textContent = ""} else m.push (b.createTextNode (f)); l.textContent = "", o = 0; while (f = m [o ++ ]) if (d && n.inArray (f, d)> - 1) e && e.push (f); else if (j = n.contains (f.ownerDocument, f), g = _ (l.appendChild (f), "script") , j && aa (g), c) {k = 0; enquanto (f = g [k ++]) Z.test (f.type || "") && c.push (f)} return l}! function () {var a = d.createDocumentFragment (), b = a.appendChild (d.createElement ("div")), c = d.createElement ("input"); c.setAttribute ("type", "radio"), c. setAttribute ("verificado", "verificado"), c.setAttribute ("nome", "t"), b.appendChild (c), l.checkClone = b.cloneNode (! 0) .cloneNode (! 0) .lastChild .checked, b.innerHTML = "<textarea> x </textarea>", l.noCloneChecked = !! b.cloneNode (! 0) .lastChild.defaultValue} (); var da = / ^ key /, ea = / ^ (?: mouse | ponteiro | menu de contexto | arrastar | soltar) | clicar /, fa = / ^ ([^.] *) (?: \. (. +) |) /; função ga () {retornar! 0 } function ha () {return!1} função ia () {try {return d.activeElement} catch (a) {}} função ja (a, b, c, d, e, f) {var g, h; if ("objeto" == typeof b) {"string"! = typeof c && (d = d || c, c = void 0); para (h in b) ja (a, h, c, d, b [h], f); retornar a } if (null == d && null == e? (e = c, d = c = void 0): null == e && ("string" == typeof c? (e = d, d = void 0) :( e = d, d = c, c = vazio 0)), e ===! 1) e = ha; senão se (! e) retornar a; retornar 1 === f && (g = e, e = função (a ) {return n (). off (a), g.apply (this, arguments)}, e.guid = g.guid || (g.guid = n.guid ++)), a.each (function () { n.evento.add (este, b, e, d, c)})} n.evento = {global: {}, adicione: função (a, b, c, d, e) {var f, g, h , i, j, k, l, m, o, p, q, r = N.get (a); if (r) {c.handler && (f = c, c = f.handler, e = f.seletor ), c.guid || (c.guid = n.guid ++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r .handle = function (b) {return "undefined"! = typeof n && n.event.triggered! == b.type? n.event.dispatch.aplicar (a, argumentos): vazio 0}), b = (b || ""). corresponder (G) || [""], j = b.length; enquanto (j -) h = fa.exec (b [j]) || [], o = q = h [1], p = (h [2] || ""). dividir ("."). sort (), o && (l = n. event.special [o] || {}, o = (e? l.delegateType: l.bindType) || o, l = n.event.special [o] || {}, k = n.extend ({ tipo: o, origType: q, data: d, manipulador: c, guid: c.guid, seletor: e, needsContext: e && n.expr.match.needsContext.test (e), namespace: p.join ("." )}, f), (m = i [o]) || (m = i [o] = [], m.delegateCount = 0, l.setup && l.setup.call (a, d, p, g)! ==! 1 || a.addEventListener && a.addEventListener (o, g)), l.add && (l.add.call (a, k), k.handler.guid || (k.handler.guid = c.guid )), e? m.splice (m.delegateCount ++, 0, k): m.push (k), n.event.global [o] =! 0)}}, remover: função (a, b, c, d, e) {var f, g, h, i, j, k, l, m, o, p, q, r = N.hasData (a) && N.get (a); if (r && (i = r .eventos)) {b = (b || "").corresponder (G) || [""], j = b.length; enquanto (j -) if (h = fa.exec (b [j]) || [], o = q = h [1], p = (h [2] || ""). split ("."). sort (), o) {l = n.event.special [o] || {}, o = (d? l.delegateType : l.bindType) || o, m = i [o] || [], h = h [2] && new RegExp ("(^ | \\.)" + p.join ("\\. (?: . * \\. |) ") +" (\\. | $) "), g = f = m.length; enquanto (f -) k = m [f] ,! e && q! == k.origType || c && c.guid! == k.guid || h &&! h.test (k.namespace) || d && d! == k.selector && ("**"! == d ||! k.selector) || (m.splice (f, 1), k.selector && m.delegateCount -, l.remove && l.remove.call (a, k)); g &&! m.length && (l.teardown && l.teardown.call (a, p, r.handle)! ==! 1 || n.removeEvent (a, o, r.handle), exclua i [o])} else for (o em i) n.event.remove (a, o + b [ j], c, d,! 0); n.isEmptyObject (i) && N.remove (a, "manipular eventos")}}, despacho: função (a) {a = n.event.fix (a); var b, c, d, f, g, h = [], i = e.call (argumentos), j = (N.get (this, "events") || {}) [a .type] || [], k = n.event.special [a.type] || {}; if (i [0] = a, a.delegateTarget = this,! k.preDispatch || k.preDispatch. call (this, a)! ==! 1) {h = n.event.handlers.call (this, a, j), b = 0; while ((f = h [b ++]) &&! a.isPropagationStopped ( )) {a.currentTarget = f.elem, c = 0; while ((g = f.handlers [c ++]) &&! a.isImmediatePropagationStopped ()) a.rnamespace &&! a.rnamespace.test (g.namespace) | | (a.handleObj = g, a.data = g.data, d = ((n.event.special [g.origType] || {}). lidar com || g.handler) .apply (f.elem, i), void 0! == d && (a.result = d) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (this, a), a.result}}, manipuladores: função (a, b) {var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && ("click" ! == a.type || isNaN (a.botão) || a.button <1)) para (; i! == this; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled! ==! 0 || " clique em "! == a.type)) {for (d = [], c = 0; h> c; c ++) f = b [c], e = f.selector +" ", vazio 0 === d [ e] && (d [e] = f.needsContext? n (e, este) .index (i)> - 1: n.find (e, este, nulo, [i]). comprimento), d [e] && d.push (f); d.length && g.push ({elem: i, manipuladores: d})} return h <b.length && g.push ({elem: this, manipuladores: b.slice (h)}), g }, props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view que" .split (""), fixHooks: {}, keyHooks: {props: "char charCode key keyCode" .split (""), filter: function (a, b) {return null == a.which && (a.which = null! = b.charCode? b.charCode: b.keyCode), a}}, mouseHooks: {props: "botão botões clientX clientY offsetX offsetY pageX pageY screenX screenY toElement ".split (" "), filter: function (a, b) {var c, e, f, g = b.button; return null == a.pageX && null! = b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e .clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a. que || void 0 === g || (a.which = 1 & g? 1: 2 & g? 3: 4 & g? 2: 0), a}}, fix: function (a) {if (a [n.expando] ) retornar a; var b, c, e, f = a.type, g = a, h = this.fixHooks [f]; h || (this.fixHooks [f] = h = ea.test (f)? this.mouseHooks: da.test (f)? this.keyHooks: {}), e = h.props? this.props.concat (h.props): this.props, a = new n.Event (g), b = comprimento e; enquanto (b -) c = e [b], a [c] = g [c]; retornar a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter? h.filter (a, g): a}, especial: {carregar: {noBubble:! 0}, focus: {trigger: function () {return this! == ia () && this.focus? (this.focus () ,! 1): void 0}, delegateType: "focusin "}, desfoque: {trigger: function () {return this === ia () && this.blur? (this.blur () ,! 1): void 0}, delegateType:" focusout "}, clique: {trigger : function () {return "checkbox" === this.type && this.click && n.nodeName (this, "input")? (this.click () ,! 1): void 0}, _ default: function (a) {return n.nodeName (a.target, "a")}}, beforeunload: {postDispatch: function (a) {void 0! == a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)}}}} , n.removeEvent = função (a, b, c) {a.removeEventListener && a.removeEventListener (b, c)}, n.Event = função (a,b) {retornar esta instância de n.Event? (a && a.type? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue = ==! 1? Ga: ha): this.type = a, b && n.extend (this, b), this.timeStamp = a && a.timeStamp || n.now (), void (this [n.expando] =! 0)): novo n.Event (a, b)}, n.Event.prototype = {construtor: n.Event, isDefaultPrevented: ha, isPropagationStopped: ha, isImmediatePropagationStopped: ha, isSimulated:! 1, preventDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = ga, a &&! this.isSimulated && a.preventDefault ()}, stopPropagation: function () {var a = this.originalEvent; this.isPropagationStopped = ga, a &&! this.isSimulated & a. stopPropagation ()}, stopImmediatePropagation: function () {var a = this.originalEvent; this.isImmediatePropagationStopped = ga, a &&! this.isSimulated && a.stopImmediatePropagation (), this.stopPropagation ()}}, n.each ({mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, função (a, b) {n.event.special [a] = {delegateType: b, bindType: b, handle: function (a) {var c, d = this, e = a.relatedTarget, f = a.handleObj; return e && (e = == d || n.contains (d, e)) || (a.type = f.origType, c = f.handler.apply (this, argumentos), a.type = b), c}}}) , n.fn.extend ({on: function (a, b, c, d) {return ja (this, a, b, c, d)}, one: function (a, b, c, d) {return ja (this, a, b, c, d, 1)}, off: function (a, b, c) {var d, e; if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n (a .delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler), this; if ("object" == typeof a) {for (e em a) this.off (e, b, a [e]);return this} return b! ==! 1 && "function"! = typeof b || (c = b, b = void 0), c ===! 1 && (c = ha), this.each (function () { n.event.remove (this, a, c, b)})}}); var ka = / <(?! area | br | col | embed | hr | img | input | link | meta | param) (( [\ w: -] +) [^>] *) \ /> / gi, la = / <script | <estilo | <link / i, ma = / verificado \ s * (?: [^ =] | = \ s * .checked.) / i, na = / ^ true \ / (. *) /, oa = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; função pa (a, b) {return n.nome do nó (a, "tabela") && n.Nome do nó (11! == b.nodeTipo? b: b.firstChild , "tr")? a.getElementsByTagName ("tbody") [0] || a.appendChild (a.ownerDocument.createElement ("tbody")): a} função qa (a) {return a.type = (null ! == a.getAttribute ("type")) + "/" + a.type, a} função ra (a) {var b = na.exec (a.type); return b? a.type = b [ 1]: a.removeAttribute ("tipo"), a} função sa (a, b) {var c, d, e, f, g, h, i, j;if (1 === b.nodeType) {if (N.hasData (a) && (f = N.acesso (a), g = N.set (b, f), j = f.events)) {delete g.handle, g.events = {}; for (e in j) for (c = 0, d = j [e] .length; d> c; c ++) n.event.add (b, e, j [ e] [c])} O.hasData (a) && (h = O.access (a), i = n.extend ({}, h), O.set (b, i))}} função ta ( a, b) {var c = b.nodeName.toLowerCase (); "input" === c && X.test (a.type)? b.checked = a.checked: "input"! == c && "textarea"! == c || (b.defaultValue = a.defaultValue)} função ua (a, b, c, d) {b = f.apply ([], b); var e, g, h, i, j, k, m = 0, o = a.length, p = o-1, q = b [0], r = n.isFunction (q); if (r || o> 1 && "string" == typeof q &&! l.checkClone && ma.test (q)) return a.each (function (e) {var f = a.eq (e); r && (b [0] = q.call (this, e, f.html ()) ), ua (f, b, c, d)}); if (o && (e = ca (b, a [0] .ownerDocument,! 1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {para (h = n.map (_ (e, "script"), qa), i = h.length; o> m; m ++) j = e, m! == p && (j = n.clone (j,! 0,! 0) , i && n.merge (h, _ (j, "script"))), c.call (a [m], j, m); if (i) para (k = h [h.length-1] .ownerDocument , n.map (h, ra), m = 0; i> m; m ++) j = h [m], Z.test (j.type || "") &&! N.access (j, "globalEval" ) && n.contains (k, j) && (j.src? n._evalUrl && n._evalUrl (j.src): n.globalEval (j.textContent.replace (oa, ""))))} retorna a} função va ( a, b, c) {para (var d, e = b? n.filtro (b, a): a, f = 0; nulo! = (d = e [f]); f ++) c || 1! == d.nodeType || n.cleanData (_ (d)), d.parentNode && (c && n.contains (d.ownerDocument, d) && aa (_ (d, "script")), d.parentNode.removeChild (d )); retornar a} n.extend ({htmlPrefilter: function (a) {return a.replace (ka, "<$ 1> </ $ 2>")}, clone: ​​function (a, b, c) {var d , e, f, g, h = a.cloneNode (! 0), i = n.contém (a.ownerDocument, a); if (! (l.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || n.isXMLDoc (a))) for (g = _ (h), f = _ ( a), d = 0, e = f.length; e> d; d ++) ta (f [d], g [d]); se (b) se (c) para (f = f || _ (a ), g = g || _ (h), d = 0, e = f.length; e> d; d ++) sa (f [d], g [d]); senão sa (a, h); retornar g = _ (h, "script"), g.length> 0 && aa (g,! i && _ (a, "script")), h}, cleanData: function (a) {for (var b, c, d, e = n.evento.special, f = 0; vazio 0! == (c = a [f]); f ++) if (L (c)) {if (b = c [N.expando]) {if (b .events) para (d in b.events) e [d]? n.event.remove (c, d): n.removeEvent (c, d, b.handle); c [N.expando] = void 0} c [O.expando] && (c [O.expando] = void 0)}}}), n.fn.extend ({domManip: ua, desanexar: function (a) {return va (this, a,! 0 )}, remova: function (a) {return va (this, a)}, text: function (a) {return K (this, function (a) {return void 0 === a? n.text (this) : this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = a)})}, null, a, arguments.length)}, acrescente: function () {return ua (this, arguments, function (a) {if ( 1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = pa (this, a); b.appendChild (a)}})}, prefixar: function () {return ua (this, argumentos, function (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = pa ( this, a); b.insertBefore (a, b.firstChild)}})}, antes de: function () {return ua (this, arguments, function (a) {this.parentNode && this.parentNode.insertBefore (a, this) })}, depois de: function () {return ua (this, arguments, function (a) {this.parentNode && this.parentNode.insertBefore (a, this.nextSibling)})}, vazio: function () {for (var a , b = 0; null! = (a = this [b]); b ++) 1 === a.nodeType && (n.cleanData (_ (a,! 1)), a.textContent = ""); retorne isso }, clone: ​​function (a, b) {return a = null == a?! 1: a, b = null == b? a: b, this.map (function () {return n.clone (this, a, b)})}, html: function (a) {return K (this, function (a) {var b = this [0] || {}, c = 0, d = this.length; if (void 0 === a && 1 === b.nodeType) return b.innerHTML; if ("string" == typeof a &&! la.test (a) &&! $ [ (Y.exec (a) || ["", ""]) [1] .toLowerCase ()]) {a = n.htmlPrefilter (a); tente {para (; d> c; c ++) b = isto [c] || {}, 1 === b.nodeType && (n.cleanData (_ (b,! 1)), b.innerHTML = a); b = 0} catch (e) {}} b && this.empty () .append (a)}, null, a, arguments.length)}, replaceWith: function () {var a = []; retornar ua (this, argumentos, function (b) {var c = this.parentNode; n.inArray (this, a) <0 && (n.cleanData (_ (this)), c && c.replaceChild (b, this))}, a)}}), n.each ({appendTo: "append", prependTo : "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function (a,b) {n.fn [a] = função (a) {para (var c, d = [], e = n (a), f = e.length-1, h = 0; f> = h; h ++ ) c = h === f? this: this.clone (! 0), n (e [h]) [b] (c), g.apply (d, c.get ()); retornar this.pushStack (d)}}); var wa, xa = {HTML: "bloco", CORPO: "bloco"}; função ya (a, b) {var c = n (b.createElement (a)). appendTo (b .body), d = n.css (c [0], "exibir"); retornar c.detach (), d} função za (a) {var b = d, c = xa [a]; retornar c | | (c = ya (a, b), "nenhum"! == c && c || (wa = (wa || n ("<iframe frameborder = '0' largura = '0' altura = '0' />" )). appendTo (b.documentElement), b = wa [0] .contentDocument, b.write (), b.close (), c = ya (a, b), wa.detach ()), xa [a ] = c), c} var Aa = / ^ margem /, Ba = new RegExp ("^ (" + S + ") (?! px) [az%] + $", "i"), Ca = função ( b) {var c = b.ownerDocument.defaultView; return c && c.opener || (c = a), c.getComputedStyle (b)}, Da = função (a, b, c, d) {var e, f,g = {}; para (f em b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []); para (f em b) a.style [f] = g [f]; retornar e}, Ea = d.documentElement;! function () {var b, c, e, f, g = d.createElement ("div "), h = d.createElement (" div "); if (h.style) {h.style.backgroundClip =" content-box ", h.cloneNode (! 0) .style.backgroundClip =" ", l. clearCloneStyle = "content-box" === h.style.backgroundClip, g.style.cssText = "border: 0; width: 8px; height: 0; top: 0; left: -9999px; padding: 0; margin- topo: 1px; posição: absoluto ", g.appendChild (h); função i () {h.style.cssText =" - webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; position: relative; display: block; margin: auto; border: 1px; padding: 1px; top: 1%; width: 50% ", h.innerHTML =" ", Ea.appendChild ( g); var d = a.getComputedStyle (h); b = "1%"! == d.top, f = "2px" === d.marginLeft, c = "4px" === d.width, h.style.marginRight = "50%", e = "4px" === d.marginRight, Ea.removeChild (g)} n.extend (l, {pixelPosition: function () {return i (), b}, boxSizingReliable: function () {return null == c && i (), c}, pixelMarginRight: function () {return null == c && i (), e}, trustedMarginLeft : function () {return null == c && i (), f}, confiávelMarginRight: function () {var b, c = h.appendChild (d.createElement ("div")); return c.style.cssText = h. style.cssText = "- webkit-box-sizing: content-box; box-sizing: content-box; display: block; margin: 0; border: 0; padding: 0", c.style.marginRight = c.style .width = "0", h.style.width = "1px", Ea.appendChild (g), b =! parseFloat (a.getComputedStyle (c) .marginRight), Ea.removeChild (g), h.removeChild ( c), b}})}} (); função Fa (a, b, c) {var d, e, f, g, h = a.style; retornar c = c || Ca (a), g = c? c.getPropertyValue (b) || c [b]: void 0, ""! == g && void 0! == g || n.contains (a.ownerDocument, a) || (g = n.style (a, b) ), c &&! l.pixelMarginRight () && Ba.test (g) && Aa.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h .width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0! == g? g + "": g} função Ga (a, b) {return {get: function () {return a ()? void delete this.get: (this.get = b) .apply (this, arguments)}}} var Ha = / ^ (none | table (?! - c [ea]). +) /, Ia = {posição: "absoluto", visibilidade: "oculto", exibição: "bloquear"}, Ja = {letterSpacing: "0", fontWeight: "400"}, Ka = ["Webkit", "O", "Moz", "ms"], La = d.createElement ("div"). Style; função Ma (a) {if (a in La) return a; var b = a [0] .toUpperCase () + a.slice (1), c = Ka.length; enquanto (c -) if (a = Ka [c] + b,a em La) retorna a} função Na (a, b, c) {var d = T.exec (b); retorna d? Math.max (0, d [2] - (c || 0)) + ( d [3] || "px"): b} função Oa (a, b, c, d, e) {for (var f = c === (d? "border": "content")? 4: "largura" === b? 1: 0, g = 0; 4> f; f + = 2) "margem" === c && (g + = n.css (a, c + U [f] ,! 0, e)), d? ("conteúdo" === c && (g- = n.css (a, "preenchimento" + U [f] ,! 0, e)), "margem"! == c && (g- = n.css (a, "borda" + U [f] + "Largura",! 0, e))) :( g + = n.css (a, "preenchimento" + U [f] ,! 0, e ), "preenchimento"! == c && (g + = n.css (a, "borda" + U [f] + "Largura",! 0, e)))); retornar g} função Pa (a, b, c ) {var d =! 0, e = "largura" === b? a.offsetWidth: a.offsetHeight, f = Ca (a), g = "border-box" === n.css (a, " boxSizing ",! 1, f); if (0> = e || null == e) {if (e = Fa (a, b, f), (0> e || null == e) && (e = a.style [b]), Ba.teste (e)) retornar e; d = g && (l.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} retornar e + Oa (a, b, c || (g? "fronteira": "conteúdo"), d, f) + "px"} função Qa (a, b) {para (var c, d, e, f = [], g = 0, h = a.length; h> g; g ++) d = a [g], d.style && (f [g] = N.get (d, "exibição antiga"), c = d.style.display, b? ( f [g] || "nenhum"! == c || (d.style.display = ""), "" === d.style.display && V (d) && (f [g] = N.access ( d, "olddisplay", za (d.nodeName)))) :( e = V (d), "none" === c && e || N.set (d, "olddisplay", e? c: n.css (d, "display")))); for (g = 0; h> g; g ++) d = a [g], d.style && (b && "none"! == d.style.display && ""! = = d.style.display || (d.style.display = b? f [g] || "": "nenhum")); retornar a} n.extend ({cssHooks: {opacidade: {get: function ( a, b) {if (b) {var c = Fa (a,"opacity"); return "" === c? "1": c}}}}, cssNumber: {animationIterationCount:! 0, columnCount:! 0, fillOpacity:! 0, flexGrow:! 0, flexShrink:! 0 , fontWeight:! 0, lineHeight:! 0, opacidade:! 0, ordem:! 0, órfãos:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0}, cssProps: {"float": " cssFloat "}, style: function (a, b, c, d) {if (a && 3! == a.nodeType && 8! == a.nodeType && a.style) {var e, f, g, h = n.camelCase (b ), i = a.style; return b = n.cssProps [h] || (n.cssProps [h] = Ma (h) || h), g = n.cssHooks [b] || n.cssHooks [ h], void 0 === c? g && "get" in g && void 0! == (e = g.get (a,! 1, d))? e: i [b] :( f = typeof c, " string "=== f && (e = T.exec (c)) && e [1] && (c = W (a, b, e), f =" número "), nulo! = c && c === c && (" número "=== f && (c + = e && e [3] || (n.cssNumber [h]?" ":" px ")), l.clearCloneStyle || ""! == c || 0! == b.indexOf ("background") || (i [b] = "herdar"), g && "definir" em g && void 0 === (c = g .set (a, c, d)) || (i [b] = c)), vazio 0)}}, css: função (a, b, c, d) {var e, f, g, h = n.camelCase (b); return b = n.cssProps [h] || (n.cssProps [h] = Ma (h) || h), g = n.cssHooks [b] || n.cssHooks [h ], g && "get" em g && (e = g.get (a,! 0, c)), void 0 === e && (e = Fa (a, b, d)), "normal" === e && b em Ja && (e = Ja [b]), "" === c || c? (f = parseFloat (e), c ===! 0 || isFinite (f)? f || 0: e): e}}), n.each (["altura", "largura"], função (a, b) {n.cssHooks [b] = {obter: função (a, c, d) {retornar c? Ha. test (n.css (a, "display")) && 0 === a.offsetWidth? Da (a, Ia, function () {return Pa (a, b, d)}): Pa (a, b, d ): vazio 0}, conjunto: função (a, c, d) {var e, f = d && Ca (a), g = d && Oa (a, b, d, "caixa-limite" === n.css (a, "boxSizing",! 1, f), f); return g && (e = T.exec (c)) && "px"! == (e [3] || "px") && (a .style [b] = c, c = n.css (a, b)), Na (a, c, g)}}}), n.cssHooks.marginLeft = Ga (l.reliableMarginLeft, função (a, b ) {return b? (parseFloat (Fa (a, "marginLeft")) || a.getBoundingClientRect (). left-Da (a, {marginLeft: 0}, function () {return a.getBoundingClientRect (). esquerda} )) + "px": void 0}), n.cssHooks.marginRight = Ga (l.reliableMarginRight, função (a, b) {return b? Da (a, {display: "inline-block"}, Fa, [a, "marginRight"]): void 0}), n.each ({margin: "", preenchimento: "", borda: "Largura"}, função (a, b) {n.cssHooks [a + b ] = {expandir: função (c) {para (var d = 0, e = {}, f = "string" == typeof c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; retornar e}}, Aa.test (a) || (n.cssHooks [a + b] .set = Na)}), n.fn.extend ({css: function (a, b) {return K (this, function (a, b, c) {var d, e, f = {}, g = 0; if (n.isArray (b)) { para (d = Ca (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); retorno f} retorno void 0! == c? n.style (a, b, c): n.css (a, b)}, a, b, arguments.length> 1)}, show: function () {return Qa (this ,! 0)}, ocultar: function () {return Qa (this)}, alternar: function (a) {return "boolean" == typeof a? A? This.show (): this.hide (): this .each (function () {V (this)? n (this) .show (): n (this) .hide ()})}}); função Ra (a, b, c, d, e) {return novo Ra.prototype.init (a, b, c, d, e)} n.Tween = Ra, Ra.prototype = {construtor: Ra, init: function (a, b, c, d, e, f) { this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur (), this.end = d , this.unit = f || (n.cssNumber [c]? "": "px")}, cur: function () {var a = Ra.propHooks [this.prop]; retornar um && a.get? a. get (this): Ra.propHooks._default.get (this)}, execute: function (a) {var b, c = Ra.propHooks [this.prop]; return this.options.duration? this.pos = b = n.easing [this.easing] (a , this.options.duration * a, 0,1, this.options.duration): this.pos = b = a, this.now = (this.end-this.start) * b + this.start, this. options.step && this.options.step.call (this.elem, this.now, this), c && c.set? c.set (this): Ra.propHooks._default.set (this), this}}, Ra.prototype .init.prototype = Ra.prototype, Ra.propHooks = {_ padrão: {get: function (a) {var b; return 1! == a.elem.nodeType || null! = a.elem [a.prop] && null == a.elem.style [a.prop]? a.elem [a.prop] :( b = n.css (a.elem, a.prop, ""), b && "auto"! == b ? b: 0)}, defina: function (a) {n.fx.step [a.prop]? n.fx.step [a.prop] (a): 1! == a.elem.nodeType || null == a.elem.style [n.cssProps [a.prop]] &&! n.cssHooks [a.prop]? a.elem [a.prop] = a.now: n.style (a.elem, a.prop, a.now + a.unit)}}}, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = {set: function (a) {a.elem.nodeType && a.elem.parentNode && (a.elem [a.prop] = a.now)}}, n.easing = {linear: function (a) {return a}, swing: function (a) {return.5-Math.cos (a * Math.PI) / 2}, _ default: "swing"}, n.fx = Ra.prototype.init, n.fx.step = {}; var Sa, Ta, Ua = / ^ (?: alternar | mostrar | ocultar) $ /, Va = / queueHooks $ /; função Wa () {return a.setTimeout (function () {Sa = vazio 0}), Sa = n.now ()} função Xa (a, b) {var c, d = 0, e = {altura: a}; para (b = b? 1: 0; 4 > d; d + = 2-b) c = U [d], e ["margem" + c] = e ["preenchimento" + c] = a; retornar b && (e.opacidade = e.width = a), e} função Ya (a, b, c) {para (var d, e = (_ a.tweeners [b] || []). concat (_a.tweeners ["*"]), f = 0, g = e.length; g> f; f ++) if (d = e [f] .call (c, b, a)) return d} função Za (a, b, c) {var d, e, f, g, h, i, j, k, l = this, m = {}, o = a.style, p = a.nodeType && V (a), q = N.get (a, "fxshow"); c.queue || (h = n._queueHooks (a,"fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {h.unqueued || i ()}), h.unqueued ++ , l.always (function () {l.always (function () {h.unqueued -, n.queue (a, "fx"). length || h.empty.fire ()})})), 1 === a.nodeType && ("altura" em b || "largura" em b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css (a, " display "), k =" none "=== j? N.get (a," olddisplay ") || za (a.nodeName): j," inline "=== k &&" none "=== n. css (a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always (function () {o.overflow = c.overflow [ 0], o.overflowX = c.overflow [1], o.overflowY = c.overflow [2]})); para (d em b) se (e = b [d], Ua.exec (e)) {if (delete b [d], f = f || "toggle" === e, e === (p? "hide": "show")) {if ("show"! == e ||! q || vazio 0 === q [d]) continue; p =! 0} m [d] = q && q [d] || n.style ( a, d)} else j = void 0; if (n.isEmptyObject (m)) "inline" === ("nenhum" === j? za (a.nodeName): j) && (o.display = j); else {q? "oculto" em q && (p = q.hidden): q = N.acesso (a, "fxshow", {}), f && (q.hidden =! p), p? n ( a) .show (): l.done (function () {n (a) .hide ()}), l.done (function () {var b; N.remove (a, "fxshow"); for ( b em m) n.style (a, b, m [b])}); para (d em m) g = Ya (p? q [d]: 0, d, l), d em q || ( q [d] = g.start, p && (g.end = g.start, g.start = "largura" === d || "altura" === d? 1: 0))}} função $ a (a, b) {var c, d, e, f, g; para (c em a) if (d = n.camelCase (c), e = b [d], f = a [c], n. isArray (f) && (e = f [1], f = a [c] = f [0]), c! == d && (a [d] = f, excluir a [c]), g = n. cssHooks [d], g && "expandir" em g) {f = g.expand (f), excluir a [d];para (c em f) c em a || (a [c] = f [c], b [c] = e)} else b [d] = e} função _a (a, b, c) {var d , e, f = 0, g = _a.prefilters.length, h = n.Deferred (). always (function () {delete i.elem}), i = function () {if (e) return! 1; for (var b = Sa || Wa (), c = Math.max (0, j.startTime + j.duration-b), d = c / j.duration || 0, f = 1-d, g = 0, i = j.tweens.length; i> g; g ++) j.tweens [g] .run (f); retornar h.notifyWith (a, [j, f, c]), 1> f && i? C: (h.resolveWith (a, [j]) ,! 1)}, j = h.promise ({elem: a, props: n.extend ({}, b), opts: n.extend (! 0, { specialEasing: {}, easing: n.easing._default}, c), originalProperties: b, originalOptions: c, startTime: Sa || Wa (), duration: c.duration, tweens: [], createTween: function (b , c) {var d = n.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); retornar j.tweens.push (d), d} , parar: função (b) {var c = 0, d = b? j.tweens.length: 0; se (e) retornar isso; para (e =! 0; d> c; c ++) j.tweens [c ] .run (1); retornar b? (h.notifyWith (a, [j, 1,0]), h.resolveWith (a,[j, b])): h.rejectWith (a, [j, b]), this}}), k = j.props; for ($ a (k, j.opts.specialEasing); g> f; f ++) if (d = _a.prefilters [f] .call (j, a, k, j.opts)) return n.isFunction (d.stop) && (n._queueHooks (j.elem, j.opts.queue ) .stop = n.proxy (d.stop, d)), d; retornar n.map (k, Ya, j), n.isFunction (j.opts.start) && j.opts.start.call (a, j), n.fx.timer (n.extend (i, {elem: a, anim: j, fila: j.opts.queue})), j.progress (j.opts.progress) .done (j. opts.done, j.opts.complete) .fail (j.opts.fail) .always (j.opts.always)} n.Animation = n.extend (_a, {tweeners: {"*": [function ( a, b) {var c = this.createTween (a, b); retornar W (c.elem, a, T.exec (b), c), c}]}, tweener: função (a, b) { n.isFunction (a)? (b = a, a = ["*"]): a = a.match (G); para (var c, d = 0, e = a.length; e> d; d ++ ) c = a [d], _ a.tweeners [c] = _ a.tweeners [c] || [], _ a.tweeners [c] .unshift (b)}, pré-filtros: [Za], pré-filtro: função (a , b) {b? _a.prefilters.unshift (a): _ a.prefilters.push (a)}}), n.speed = function (a, b, c) {var d = a && "object" == typeof a? n.extend ({}, a): {complete: c ||! c && b || n.isFunction (a) && a, duração: a, atenuação: c && b || b &&! n.isFunction (b) && b}; return d.duration = n.fx.off? 0: "número" == typeof d.duration? d.duration: d.duration em n.fx.speeds? n.fx.speeds [d.duration]: n.fx.speeds._default, null! = d.queue && d.queue! ==! 0 || (d.queue = "fx"), d.old = d.complete, d.complete = function () {n.isFunction (d.old) && d.old.call (this), d.queue && n.dequeue (this, d.queue)}, d}, n.fn.extend ({fadeTo: function (a, b, c, d) {return this.filter (V) .css ("opacity", 0) .show () .end (). animate ({opacity: b}, a, c, d)}, anime: function (a, b, c, d) {var e = n.isEmptyObject (a), f = n. velocidade (b, c, d), g = function () {var b = _a (this, n.extend ({}, a), f); (e || N.get (this, "terminar")) && b.stop (!0)}; return g.finish = g, e || f.queue ===! 1? This.each (g): this.queue (f.queue, g)}, stop: function (a, b, c) {var d = function (a) {var b = a.stop; delete a.stop, b (c)}; return "string"! = typeof a && (c = b, b = a, a = void 0 ), b && a! ==! 1 && this.queue (a || "fx", []), this.each (function () {var b =! 0, e = null! = a && a + "queueHooks", f = n. temporizadores, g = N.get (this); if (e) g [e] && g [e] .stop && d (g [e]); else for (e in g) g [e] && g [e] .stop && Va. test (e) && d (g [e]); para (e = f.length; e -;) f [e] .elem! == this || null! = a && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1, f.splice (e, 1)) ;! b && c || n.dequeue (this, a)})}, terminar: função ( a) {return a! ==! 1 && (a = a || "fx"), this.each (function () {var b, c = N.get (this), d = c [a + "queue"] , e = c [a + "queueHooks"], f = n.timers, g = d? d.length: 0; para (c.finish =! 0, n.queue (this, a, []),e && e.stop && e.stop.call (this,! 0), b = f.length; b -;) f [b] .elem === this && f [b] .queue === a && (f [b]. anim.stop (! 0), f.splice (b, 1)); para (b = 0; g> b; b ++) d [b] && d [b] .finish && d [b] .finish.call (this) ; excluir c.finish})}}), n.each (["alternar", "mostrar", "ocultar"], função (a, b) {var c = n.fn [b]; n.fn [ b] = função (a, d, e) {return null == a || "boolean" == typeof a? c.apply (this, argumentos): this.animado (Xa (b,! 0), a, d, e)}}), n.each ({slideDown: Xa ("show"), slideUp: Xa ("ocultar"), slideToggle: Xa ("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, function (a, b) {n.fn [a] = function (a, c, d) {return this.animate (b , a, c, d)}}), n.timers = [], n.fx.tick = function () {var a, b = 0, c = n.timers; para (Sa = n.now () ; b <c.length; b ++) a = c [b], a () || c [b]! == a || c.splice (b -, 1); c.length || n.fx.stop (), Sa = vazio 0}, n.fx.timer = função (a) {n.timers.push (a), a ( )? n.fx.start (): n.timers.pop ()}, n.fx.interval = 13, n.fx.start = function () {Ta || (Ta = a.setInterval (n.fx .tick, n.fx.interval))}, n.fx.stop = function () {a.clearInterval (Ta), Ta = null}, n.fx.speeds = {lento: 600, rápido: 200, _padrão : 400}, n.fn.delay = function (b, c) {return b = n.fx? N.fx.speeds [b] || b: b, c = c || "fx", this.queue (c, função (c, d) {var e = a.setTimeout (c, b); d.stop = function () {a.clearTimeout (e)}})}, função () {var a = d. createElement ("input"), b = d.createElement ("select"), c = b.appendChild (d.createElement ("option")); a.type = "checkbox", l.checkOn = ""! = = a.value, l.optSelected = c.selected, b.disabled =! 0, l.optDisabled =! c.disabled, a = d.createElement ("input"), a.value = "t", a. type = "radio", l.radioValue = "t" === a.valor} (); var ab, bb = n.expr.attrHandle; n.fn.extend ({attr: function (a, b) {return K (this, n.attr, a, b, arguments.length> 1 )}, removeAttr: function (a) {return this.each (function () {n.removeAttr (this, a)})}}), n.extend ({attr: function (a, b, c) {var d, e, f = a.nodeType; if (3! == f && 8! == f && 2! == f) return "undefined" == typeof a.getAttribute? n.prop (a, b, c) :( 1 === f && n.isXMLDoc (a) || (b = b.toLowerCase (), e = n.attrHooks [b] || (n.expr.match.bool.test (b)? ab: void 0)) , void 0! == c? null === c? void n.removeAttr (a, b): e && "set" in e && void 0! == (d = e.set (a, c, b))? d : (a.setAttribute (b, c + ""), c): e && "get" em e && null! == (d = e.get (a, b))? d: (d = n.find.attr (a , b), null == d? void 0: d))}, attrHooks: {type: {set: function (a, b) {if (! l.radioValue && "radio" === b && n.nodeName (a, "input")) {var c = a.value; return a.setAttribute ("tipo", b), c && (a.value = c), b}}}}, removeAttr: função (a, b) {var c, d, e = 0, f = b && b.match (G) ; if (f && 1 === a.nodeType) while (c = f [e ++]) d = n.propFix [c] || c, n.expr.match.bool.test (c) && (a [d] =! 1), a.removeAttribute (c)}}), ab = {set: function (a, b, c) {return b ===! 1? N.removeAttr (a, c): a.setAttribute ( c, c), c}}, n.each (n.expr.match.bool.source.match (/ \ w + / g), função (a, b) {var c = bb [b] || n. find.attr; bb [b] = função (a, b, d) {var e, f; return d || (f = bb [b], bb [b] = e, e = null! = c (a , b, d)? b.toLowerCase (): null, bb [b] = f), e}}); var cb = / ^ (?: input | select | textarea | botão) $ / i, db = / ^ (?: a | area) $ / i; n.fn.extend ({prop: function (a, b) {return K (this, n.prop, a, b, arguments.length> 1)}, removeProp : function (a) {return this.each (function () {delete this [n.propFix [a] || a]})}}), n.extend ({prop: function (a, b, c) { var d, e, f = a.nodeType; if (3! == f && 8! == f && 2!== f) return 1 === f && n.isXMLDoc (a) || (b = n.propFix [b] || b, e = n.propHooks [b]),
void 0! == c? e && "set" in e && void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" in e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {var b = n.find.attr (a, "tabindex"); return b? parseInt (b, 10): cb.test (a.nodeName) || db.test (a.nodeName) && a.href? 0: -1}}}, propFix: {"for": "htmlFor" , "class": "className"}}), l.optSelected || (n.propHooks.selected = {get: function (a) {var b = a.parentNode; return b && b.parentNode && b.parentNode.selectedIndex, null} , definir: function (a) {var b = a.parentNode; b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)}}), n.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder "," contentEditable "], function () {n.propFix [this.toLowerCase ()] = this}); var eb = / [\ t \ r \ n \ f] / g; função fb (a) { return a.getAttribute && a.getAttribute ("class") || ""} n.fn.extend ({addClass: function (a) {var b, c, d, e, f, g, h, i = 0; se (n.isFunction (a)) return this.each (function (b) {n (this) .addClass (a.call (this, b, fb (this)))}); if ("string" == typeof a && a) {b = a.match (G) || []; enquanto (c = this [i ++]) if (e = fb (c), d = 1 === c.nodeType && ("" + e + "" ) .replace (eb, "")) {g = 0; while (f = b [g ++]) d.indexOf ("" + f + "") <0 && (d + = f + ""); h = n.trim (d), e! == h && c.setAttribute ("class", h)}} retornar isso}, removeClass: function (a) {var b, c, d, e, f, g, h, i = 0; if (n.isFunction (a)) retorna this.each (function (b) {n (this) .removeClass (a.call (this, b, fb (this)))}); if (! argumentos.comprimento) retorna this.attr ("classe", ""); if ("string" == typeof a &&a) {b = a.match (G) || []; enquanto (c = this [i ++]) if (e = fb (c), d = 1 === c.nodeType && ("" + e + "" ) .replace (eb, "")) {g = 0; while (f = b [g ++]) while (d.indexOf ("" + f + "")> - 1) d = d.replace ("" + f + "", ""); h = n.trim (d), e! == h && c.setAttribute ("class", h)}} retornar isso}, toggleClass: function (a, b) {var c = typeof a; return "boolean" == typeof b && "string" === c? b? this.addClass (a): this.removeClass (a): n.isFunction (a)? this.each (function (c) { n (this) .toggleClass (a.call (this, c, fb (this), b), b)}): this.each (function () {var b, d, e, f; if ("string" === c) {d = 0, e = n (este), f = a.match (G) || []; enquanto (b = f [d ++]) e.hasClass (b)? e.removeClass ( b): e.addClass (b)} else void 0! == a && "boolean"! == c || (b = fb (this), b && N.set (this, "__ className __", b), this.setAttribute && this.setAttribute ("class", b || a ===! 1? "": N.get (this, "__ className __") || ""))})}, hasClass: function (a) {var b , c, d = 0; b = "" + a + ""; enquanto (c = this [d ++]) if (1 === c.nodeType && ("" + fb (c) + "") .replace (eb , "") .indexOf (b)> - 1) return! 0; return! 1}}); var gb = / \ r / g, hb = / [\ x20 \ t \ r \ n \ f] + / g; n.fn.extend ({val: function (a) {var b, c, d, e = this [0]; {if (arguments.length) return d = n.isFunction (a), this.each (função (c) {var e; 1 === this.nodeType && (e = d? a.call (this, c, n (this) .val ()): a, null == e? e = "" : "número" == typeof e? e + = "": n.isArray (e) && (e = n.map (e, função (a) {return null == a? "": a + ""})) , b = n.valHooks [this.type] || n.valHooks [this.nodeName.toLowerCase ()], b && "definir" em b && void 0! == b.set (this, e,"valor") || (this.value = e))}); if (e) return b = n.valHooks [e.type] || n.valHooks [e.nodeName.toLowerCase ()], b && "get "in b && void 0! == (c = b.get (e," valor "))? c: (c = e.value," string "== typeof c? c.replace (gb," "): null == c? "": c)}}}), n.extend ({valHooks: {opção: {get: function (a) {var b = n.find.attr (a, "valor"); retornar nulo ! = b? b: n.trim (n.text (a)). replace (hb, "")}}, selecione: {get: function (a) {for (var b, c, d = a.options , e = a.selectedIndex, f = "selecionar um" === a.type || 0> e, g = f? null: [], h = f? e + 1: d.length, i = 0 > e? h: f? e: 0; h> i; i ++) if (c = d [i], (c.selecionado || i === e) && (l.optDisabled?! c.disabled: null === c.getAttribute ("disabled")) && (! c.parentNode.disabled ||! n.nodeName (c.parentNode, "optgroup"))) {if (b = n (c) .val () , f) return b; g.push (b)} return g}, set: function (a,b) {var c, d, e = a.options, f = n.makeArray (b), g = e.length; enquanto (g -) d = e [g], (d.selected = n.inArray (n.valHooks.option.get (d), f)> - 1) && (c =! 0); retornar c || (a.selectedIndex = -1), f}}}}), n.each ( ["radio", "checkbox"], function () {n.valHooks [this] = {set: function (a, b) {return n.isArray (b)? a.checked = n.inArray (n (a ) .val (), b)> - 1: void 0}}, l.checkOn || (n.valHooks [this] .get = function (a) {return null === a.getAttribute ("value") ? "on": a.value})}); var ib = / ^ (?: focusinfocus | focusoutblur) $ /; n.extend (n.event, {trigger: function (b, c, e, f) { var g, h, i, j, l, m, o, p = [e || d], q = k.call (b, "tipo")? b.type: b, r = k.call (b , "namespace")? b.namespace.split ("."): []; if (h = i = e = e || d, 3! == e.nodeType && 8! == e.nodeType &&! ib.test (q + n.evento.triggered) && (q.indexOf (".")> - 1 && (r = q.split ("."), q = r.shift (), r.sort ()), l = q.indexOf (":") <0 && "on" + q, b = b [n.expando]? b: novo n.Event (q, "objeto" == typeof b && b), b.isTrigger = f? 2: 3, b.namespace = r.join ("."), b.rnamespace = b.namespace? new RegExp ("(^ | \\.)" + r.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, b.result = void 0, b.target || (b.target = e), c = null == c? [b]: n.makeArray (c, [b]), o = n.event.special [q] || {}, f ||! o.trigger || o.trigger.apply (e, c)! ==! 1)) {if (! f &&! o.noBubble &&! n.isWindow (e)) {for (j = o.delegateType || q, ib.test ( j + q) || (h = h.parentNode); h; h = h.parentNode) p.push (h), i = h; i === (e.ownerDocument || d) && p.push (i .defaultView || i.parentWindow || a)} g = 0; while ((h = p [g ++]) &&! b.isPropagationStopped ()) b.type = g> 1? j: o.bindType || q , m = (N.get (h, "eventos") || {}) [b.tipo] && N.get (h, "manipular"), m && m.aplicar (h, c),m = l && h [l], m && m.apply && L (h) && (b.result = m.apply (h, c), b.result ===! 1 && b.preventDefault ()); return b.type = q, f || b.isDefaultPrevented () || o._default && o._default.apply (p.pop (), c)! ==! 1 ||! L (e) || l && n.isFunction (e [q]) &&! n.isWindow (e) && (i = e [l], i && (e [l] = nulo), n.event.triggered = q, e [q] (), n.event.triggered = void 0, i && (e [l] = i)), b.resultado}}, simular: função (a, b, c) {var d = n.extend (novo n.Evento, c, {tipo: a, isSimulated:! 0 }); n.event.trigger (d, null, b)}}), n.fn.extend ({trigger: function (a, b) {return this.each (function () {n.event.trigger ( a, b, this)})}, triggerHandler: function (a, b) {var c = this [0]; return c? n.event.trigger (a, b, c,! 0): void 0}} ), n.each ("desfocar foco foco em foco fora carregar redimensionar rolar descarregar clique dblclique mouse para baixo mouseup mousemove mouseover mouseout mouseentre o mouseentre mudar selecionar enviar tecla pressionada tecla pressionada tecla para cima erro contextmenu ".split (" "), função (a, b) {n.fn [b] = função (a , c) {return arguments.length> 0? this.on (b, null, a, c): this.trigger (b)}}), n.fn.extend ({hover: function (a, b) { retornar this.mouseenter (a) .mouseleave (b || a)}}), l.focusin = "onfocusin" em a, l.focusin || n.each ({focus: "focusin", desfoque: "focusout" }, function (a, b) {var c = function (a) {n.event.simulate (b, a.target, n.event.fix (a))}; n.event.special [b] = { configuração: function () {var d = this.ownerDocument || this, e = N.access (d, b); e || d.addEventListener (a, c,! 0), N.access (d, b, (e || 0) +1)}, desmontar: function () {var d = this.ownerDocument || this, e = N.access (d, b) -1; e? N.access (d, b, e) :( d.removeEventListener (a, c,! 0), N.remove (d, b))}}}); var jb = a.location, kb = n.now (), lb = / \? /; n.parseJSON = function (a) {return JSON.parse (a + " ")}, n.parseXML = function (b) {var c; if (! b ||" string "! = typeof b) return null; try {c = (new a.DOMParser) .parseFromString (b," text / xml ")} catch (d) {c = void 0} return c &&! c.getElementsByTagName (" parsererror "). length || n.error (" XML inválido: "+ b), c}; var mb = / #. * $ /, nb = / ([? &]) _ = [^ &] * /, ob = / ^ (. *?): [\ t] * ([^ \ r \ n] *) $ /gm,pb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,qb=/^(?:GET|HEAD)$/,rb=/ ^ \ / \ //, sb = {}, tb = {}, ub = "* /". concat ("*"), vb = d.createElement ("a"); vb.href = jb.href; function wb (a) {return function (b, c) {"string"! = typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase (). match ( G) || []; if (n.isFunction (c)) while (d = f [e ++]) "+" === d [0]? (D = d.fatia (1) || "*", (a [d] = a [d] || []). unshift (c)) :( a [d] = a [d] || []). push ( c)}} função xb (a, b, c, d) {var e = {}, f = a === tb; função g (h) {var i; retornar e [h] =! 0, n. each (a [h] || [], função (a, h) {var j = h (b, c, d); return "string"! = typeof j || f || e [j]? f? ! (i = j): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}), i} return g (b.dataTypes [0]) ||! e ["* "] && g (" * ")} função yb (a, b) {var c, d, e = n.ajaxSettings.flatOptions || {}; para (c em b) void 0! == b [c] && ((e [c]? a: d || (d = {})) [c] = b [c]); retornar d && n.extend (! 0, a, d), a} função zb (a, b , c) {var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i [0]) i.shift (), void 0 === d && (d = a.mimeType || b.getResponseHeader ("Content-Type")); if (d) for (e in h) if (h [e] && h [e] .test (d)) {i.unshift (e); quebrar} if (i [0] em c) f = i [0]; else {for (e em c) {if (! i [0] || a.conversores [e + "" + i [ 0]]) {f = e;break} g || (g = e)} f = f || g} return f? (f! == i [0] && i.unshift (f), c [f]): void 0} função Ab (a , b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice (); if (k [1]) para (g em a.conversores) j [g.toLowerCase ()] = a.converters [g]; f = k.shift (); while (f) if (a.responseFields [f] && (c [a.responseFields [f]] = b), ! i && d && a.dataFilter && (b = a.dataFilter (b, a.dataType)), i = f, f = k.shift ()) if ("*" === f) f = i; else if ("* "! == i && i! == f) {if (g = j [i +" "+ f] || j [" * "+ f] ,! g) para (e em j) if (h = e.split (""), h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0]])) {g ===! 0? g = j [e]: j [e]! ==! 0 && (f = h [0], k.unshift (h [1])); quebrar} if (g! ==! 0) if (g && a [ "lança"]) b = g (b); caso contrário, tente {b = g (b)} catch (l) {return {state: "parsererror", erro: g? l: "Sem conversão de" + i + "para "+ f}}} return {state:"sucesso", dados: b}} n.extend ({ativo: 0, lastModified: {}, etag: {}, ajaxSettings: {url: jb.href, digite: "GET", isLocal: pb.test (jb .protocol), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8", aceita: {"*": ub, text: "text / plain", html: "text / html", xml: "application / xml, text / xml", json: "application / json, text / javascript"}, conteúdo: {xml: / \ bxml \ b / , html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"}, conversores: {"* text": String, "text html":! 0, "text json": n.parseJSON, "text xml": n.parseXML}, flatOptions: {url:! 0, context:! 0}}, ajaxSetup: function (a, b) {return b? yb (yb (a, n.ajaxSettings), b): yb (n.ajaxSettings, a)}, ajaxPrefilter: wb (sb),ajaxTransport: wb (tb), ajax: function (b, c) {"object" == typeof b && (c = b, b = void 0), c = c || {}; var e, f, g, h , i, j, k, l, m = n.ajaxSetup ({}, c), o = m.context || m, p = m.context && (o.nodeType || o.jquery)? n (o) : n.evento, q = n.Deferred (), r = n.Chamada de volta ("uma vez na memória"), s = m.statusCode || {}, t = {}, u = {}, v = 0, w = "cancelado", x = {readyState: 0, getResponseHeader: function (a) {var b; if (2 === v) {if (! h) {h = {}; while (b = ob.exec ( g)) h [b [1] .toLowerCase ()] = b [2]} b = h [a.toLowerCase ()]} return null == b? null: b}, getAllResponseHeaders: function () {return 2 === v? g: null}, setRequestHeader: function (a, b) {var c = a.toLowerCase (); retornar v || (a = u [c] = u [c] || a, t [ a] = b), este}, overrideMimeType: function (a) {return v || (m.mimeType = a), this}, statusCode: function (a) {var b; if (a) if (2> v ) para (b em a) s [b] = [s [b], a [b]]; caso contrário, x.always (a [x.status]); retornar isso}, abortar: função (a) {var b = a || w; retornar e && e.abortar (b), z (0, b), este}}; if (q.prometer (x) .completo = r.add, x.sucesso = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + ""). replace (mb, ""). replace (rb, jb.protocol + "//"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim (m.dataType || "*"). toLowerCase (). match (G) || [""], null == m.crossDomain) {j = d.createElement ("a"); tente {j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + "//" + vb.host! = j.protocol + "//" + j.host} catch (y) {m.crossDomain =! 0}} if (m.data && m.processData && "string"! = typeof m.data && (m.data = n.param (m.data, m.traditional)), xb (sb, m, c, x), 2 === v) retornar x; k = n.evento && m.global, k && 0 === n.active ++ && n. event.trigger ("ajaxStart"), m.type = m.type.toUpperCase (), m.hasContent =! qb.test (m.type), f = m.url, m.hasContent || (m.data && (f = m.url + = (lb.test (f)? "&": "?") + m.data, excluir m.data), m.cache ===! 1 && (m.url = nb. test (f)? f.replace (nb, "$ 1 _ =" + kb ++): f + (lb.test (f)? "&": "?") + "_ =" + kb ++)), m.ifModificado && (n.lastModified [f] && x.setRequestHeader ("If-Modified-Since", n.lastModified [f]), n.etag [f] && x.setRequestHeader ("If-None-Match", n.etag [f ])), (m.data && m.hasContent && m.contentType! ==! 1 || c.contentType) && x.setRequestHeader ("Content-Type", m.contentType), x.setRequestHeader ("Aceitar", m.dataTypes [ 0] && m.accepts [m.dataTypes [0]]? M.accepts [m.dataTypes [0]] + ("*"! == m.dataTypes [0]? "," + Ub + "; q = 0,01 ":" "): m.accepts [" * "]); para (l em m.headers) x.setRequestHeader (l, m.headers [l]); if (m.beforeSend && (m.beforeSend.call (o, x, m) ===! 1 || 2 === v)) return x.abort (); w = "abortar"; for (l em {sucesso: 1, erro: 1, completo: 1}) x [l] (m [l]); if (e = xb (tb, m, c, x)) {if (x.readyState = 1, k && p.trigger ("ajaxSend ", [x, m]), 2 === v) return x; m.async && m.timeout> 0 && (i = a.setTimeout (function () {x.abort (" timeout ")}, m.timeout) ); tente {v = 1, e.send (t, z)} catch (y) {if (! (2> v)) lance y; z (-1, y)}} else z (-1, " Sem transporte "); função z (b, c, d, h) {var j, l, t, u, w, y = c; 2! == v && (v = 2, i && a.clearTimeout (i), e = void 0, g = h || "", x.readyState = b> 0? 4: 0, j = b> = 200 && 300> b || 304 === b, d && (u = zb (m, x, d)), u = Ab (m, u, x, j), j? (m.ifModificado && (w = x.getResponseHeader ("Última modificação"), w && (n.últimoModificado [f] = w), w = x.getResponseHeader ("etag"), w && (n.etag [f] = w)), 204 === b || "HEAD "=== m.type? Y =" nocontent ": 304 === b? Y =" notmodified ":( y = u.state, l = u.data, t = u.error, j =! T )) :( t = y,! b && y || (y = "erro", 0> b && (b = 0))), x.status = b, x.statusText = (c || y) + "", j? q.resolveWith (o, [l, y, x]): q.rejectWith (o, [x, y, t]), x.statusCode (s), s = void 0, k && p.trigger (j? "ajaxSuccess": "ajaxError", [x, m, j? l: t]), r.fireWith (o, [x, y]), k && (p.trigger ("ajaxComplete", [x, m]) , - n.active || n.event.trigger ("ajaxStop")))} return x}, getJSON: function (a, b, c) {return n.get (a, b, c, "json" )}, getScript: function (a, b) {return n.get (a, void 0, b, "script")}}), n.each (["get", "post"], function (a, b) {n [b] = função (a, c, d, e) {retornar n.isFunção (c) && (e = e || d, d = c, c = vazio 0), n.ajax (n .extend ({url: a, tipo: b, dataType: e, dados: c, sucesso: d}, n.isPlainObject (a) && a))}}), n._evalUrl = function (a) {return n.ajax ({url: a, digite: "GET", dataType: "script", assíncrono:! 1, global :! 1, "lança":! 0})}, n.fn.extend ({wrapAll: function (a) {var b; return n.isFunction (a)? This.each (function (b) {n (this) .wrapAll (a.call (this, b))}) :( this [0] && (b = n (a, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0 ] .parentNode && b.insertBefore (this [0]), b.map (function () {var a = this; while (a.firstElementChild) a = a.firstElementChild; return a}). append (this)), this) }, wrapInner: function (a) {return n.isFunction (a)? this.each (function (b) {n (this) .wrapInner (a.call (this, b))}): this.each (function () {var b = n (this), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = n.isFunction (a); retornar this.each (function (c) {n (this) .wrapAll (b? a.call (this, c): a)})}, desembrulhar: function () {return this. pai ().each (function () {n.nodeName (this, "body") || n (this) .replaceWith (this.childNodes)}). end ()}}), n.expr.filters.hidden = function (a ) {return! n.expr.filters.visible (a)}, n.expr.filters.visible = function (a) {return a.offsetWidth> 0 || a.offsetHeight> 0 || a.getClientRects (). comprimento> 0}; var Bb = /% 20 / g, Cb = / \ [\] $ /, Db = / \ r? \ n / g, Eb = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, Fb = / ^ (?: input | select | textarea | keygen) / i; função Gb (a, b, c, d) {var e; if (n.isArray (b)) n. each (b, function (b, e) {c || Cb.test (a)? d (a, e): Gb (a + "[" + ("object" == typeof e && null! = e? b: " ") +"] ", e, c, d)}); else if (c ||" objeto "! == n.tipo (b)) d (a, b); senão para (e em b) Gb (a + "[" + e + "]", b [e], c, d)} n.param = função (a, b) {var c, d = [], e = função (a, b) {b = n.isFunction (b)? b (): null == b? "": b, d [d.length] = encodeURIComponent (a) + "="+ encodeURIComponent (b)}; if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray (a) || a.jquery &&! n.isPlainObject (a)) n.each ( a, function () {e (this.name, this.value)}); else for (c em a) Gb (c, a [c], b, e); return d.join ("&"). replace (Bb, "+")}, n.fn.extend ({serialize: function () {return n.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var a = n.prop (this, "elements"); retornar um? n.makeArray (a): this}). filter (function () {var a = this.type; return this.name &&! n (this ) .is (": disabled") && Fb.test (this.nodeName) &&! Eb.test (a) && (this.checked ||! X.test (a))}). map (function (a, b ) {var c = n (this) .val (); return null == c? null: n.isArray (c)? n.map (c, function (a) {return {name: b.name, value: a.replace (Db, "\ r \ n")}}): {nome: b.nome, valor: c.replace (Db,"\ r \ n")}}). get ()}}), n.ajaxSettings.xhr = function () {try {return new a.XMLHttpRequest} catch (b) {}}; var Hb = {0: 200,1223: 204}, Ib = n.ajaxSettings.xhr (); l.cors = !! Ib && "withCredentials" em Ib, l.ajax = Ib = !! Ib, n.ajaxTransport (function (b) {var c, d; return l.cors || Ib &&! b.crossDomain? {send: function (e, f) {var g, h = b.xhr (); if (h.open (b.type, b.url , b.async, b.username, b.password), b.xhrFields) para (g em b.xhrFields) h [g] = b.xhrFields [g]; b.mimeType && h.overrideMimeType && h.overrideMimeType (b.mimeType) , b.crossDomain || e ["X-Requested-With"] || (e ["X-Requested-With"] = "XMLHttpRequest"); for (g em e) h.setRequestHeader (g, e [g ]); c = function (a) {return function () {c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abortar" === a? h.abort (): "erro" === a? "número"! = tipo de h.status? f (0, "erro"): f (h.status, h.statusText): f (Hb [h.status] || h.status, h.statusText, "text"! == (h.responseType || "texto") || "string"! = typeof h.responseText? {binary: h.response}: {text: h.responseText}, h.getAllResponseHeaders ()))}}, h.onload = c ( ), d = h.onerror = c ("erro"), void 0! == h.onabort? h.onabort = d: h.onreadystatechange = function () {4 === h.readyState && a.setTimeout (function ( ) {c && d ()})}, c = c ("abortar"); tente {h.send (b.hasContent && b.data || null)} catch (i) {if (c) throw i}}, abortar: function () {c && c ()}}: void 0}), n.ajaxSetup ({aceita: {script: "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, conteúdo: {script : / \ b (?: java | ecma) script \ b /}, conversores: {"script de texto": function (a) {return n.globalEval (a), a}}}), n.ajaxPrefilter ("script ", função (a) {void 0 === a.cache && (a.cache =! 1), a.crossDomain && (a.type =" GET ")}), n.ajaxTransport (" script ", função ( a) {if (a.crossDomain) {var b, c; return {enviar: função (e, f) {b = n ("<script>") .prop ({charset: a.scriptCharset, src: a. url}). on ("carregar erro", c = função (a) {b.remove (), c = null, a && f ("erro" === a.type? 404: 200, a.type)}) , d.head.appendChild (b [0])}, abort: function () {c && c ()}}}}); var Jb = [], Kb = / (=) \? (? = & | $) | \? \? /; n.ajaxSetup ({jsonp: "callback", jsonpCallback: function () {var a = Jb.pop () || n.expando + "_" + kb ++; return this [a] =! 0, a}}), n.ajaxPrefilter ("json jsonp", função (b, c, d) {var e, f, g, h = b.jsonp! ==! 1 && (Kb.test (b.url )? "url": "string" == typeof b.data && 0 === (b.contentType || ""). indexOf ("application / x-www-form-urlencoded ") && Kb.test (b.data) &&" data "); return h ||" jsonp "=== b.dataTypes [0]? (e = b.jsonpCallback = n .isFunction (b.jsonpCallback)? b.jsonpCallback (): b.jsonpCallback, h? b [h] = b [h] .replace (Kb, "$ 1" + e): b.jsonp! ==! 1 && ( b.url + = (lb.test (b.url)? "&": "?") + b.jsonp + "=" + e), b.converters ["script json"] = function () {return g | | n.error (e + "não foi chamado"), g [0]}, b.dataTypes [0] = "json", f = a [e], a [e] = função () {g = argumentos} , d.always (function () {void 0 === f? n (a) .removeProp (e): a [e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, Jb.push (e)), g && n.isFunction (f) && f (g [0]), g = f = void 0}), "script"): void 0}), n.parseHTML = function (a, b, c) {if (! a || "string"! = typeof a) return null; "boolean" == typeof b && (c = b,b =! 1), b = b || d; var e = x.exec (a), f =! c && []; return e? [b.createElement (e [1])] :( e = ca ( [a], b, f), f && f.length && n (f) .remove (), n.merge ([], e.childNodes))}; var Lb = n.fn.load; n.fn.load = função (a, b, c) {if ("string"! = typeof a && Lb) return Lb.apply (this, arguments); var d, e, f, g = this, h = a.indexOf (""); return h> -1 && (d = n.trim (a.slice (h)), a = a.slice (0, h)), n.isFunction (b)? (c = b, b = vazio 0): b && "object" == typeof b && (e = "POST"), g.length> 0 && n.ajax ({url: a, type: e || "GET", dataType: "html", data: b}). feito (função (a) {f = argumentos, g.html (d? n ("<div>") .append (n.parseHTML (a)). find (d): a)}). always (c && function (a) , b) {g.each (function () {c.apply (this, f || [a.responseText, b, a])})}), this}, n.each (["ajaxStart", "ajaxStop "," ajaxComplete ", "ajaxError", "ajaxSuccess", "ajaxSend"], função (a, b) {n.fn [b] = função (a) {return this.on (b, a)}}), n.expr. filtros.animado = função (a) {retornar n.grep (n.timers, função (b) {retornar a === b.elem}). comprimento}; função Mb (a) {retornar n.isWindow (a) ? a: 9 === a.nodeType && a.defaultView} n.offset = {setOffset: function (a, b, c) {var d, e, f, g, h, i, j, k = n.css ( a, "posição"), l = n (a), m = {}; "estático" === k && (a.style.position = "relativo"), h = l.offset (), f = n. css (a, "superior"), i = n.css (a, "esquerda"), j = ("absoluto" === k || "fixo" === k) && (f + i) .indexOf ("auto")> - 1, j? (d = l.position (), g = d.top, e = d.left) :( g = parseFloat (f) || 0, e = parseFloat (i) || 0), n.isFunction (b) && (b = b.call (a, c, n.extend ({}, h))), null! = B.top && (m.top = b.top- h.top + g), null! = b.esquerdo && (m.esquerdo = b.esquerdo-h.esquerdo + e),"usando" em b? b.using.call (a, m): l.css (m)}}, n.fn.extend ({offset: function (a) {if (arguments.length) return void 0 = == a? this: this.each (function (b) {n.offset.setOffset (this, a, b)}); var b, c, d = this [0], e = {top: 0, left : 0}, f = d && d.ownerDocument; if (f) return b = f.documentElement, n.contains (b, d)? (E = d.getBoundingClientRect (), c = Mb (f), {top: e .top + c.pageYOffset-b.clientTop, esquerda: e.left + c.pageXOffset-b.clientLeft}): e}, posição: function () {if (this [0]) {var a, b, c = this [0], d = {top: 0, left: 0}; return "fixed" === n.css (c, "position")? b = c.getBoundingClientRect () :( a = this.offsetParent (), b = this.offset (), n.nome do nó (a [0], "html") || (d = a.offset ()), d.top + = n.css (a [0], " borderTopWidth ",! 0), d.left + = n.css (a [0]," borderLeftWidth ",! 0)), {top: b.top-d.top-n.css (c," marginTop ", ! 0), esquerda: b.left-d.left-n.css (c, "marginLeft",! 0)}}},offsetParent: function () {return this.map (function () {var a = this.offsetParent; while (a && "static" === n.css (a, "position")) a = a.offsetParent; return a || Ea})}}), n.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, função (a, b) {var c = "pageYOffset" === b; n.fn [a ] = function (d) {return K (this, function (a, d, e) {var f = Mb (a); return void 0 === e? f? f [b]: a [d]: void (f? f.scrollTo (c? f.pageXOffset: e, c? e: f.pageYOffset): a [d] = e)}, a, d, arguments.length)}}), n.each ([ "top", "left"], function (a, b) {n.cssHooks [b] = Ga (l.pixelPosition, function (a, c) {return c? (c = Fa (a, b), Ba .test (c)? n (a) .position () [b] + "px": c): void 0})}), n.each ({Height: "height", Width: "width"}, função (a, b) {n.each ({preenchimento: "interno" + a, conteúdo: b, "": "externo" + a}, função (c, d) {n.fn [d] = função ( d,e) {var f = argument.length && (c || "boolean"! = typeof d), g = c || (d ===! 0 || e ===! 0? "margin": "border" ); return K (this, function (b, c, d) {var e; return n.isWindow (b)? b.document.documentElement ["client" + a]: 9 === b.nodeType? (e = b.documentElement, Math.max (b.body ["scroll" + a], e ["scroll" + a], b.body ["offset" + a], e ["offset" + a], e ["cliente" + a])): vazio 0 === d? n.css (b, c, g): n.style (b, c, d, g)}, b, f? d: vazio 0 , f, null)}})}), n.fn.extend ({bind: function (a, b, c) {return this.on (a, null, b, c)}, unbind: function (a, b) {return this.off (a, null, b)}, delegate: function (a, b, c, d) {return this.on (b, a, c, d)}, undelegate: function (a, b, c) {return 1 === arguments.length? this.off (a, "**"): this.off (b, a || "**", c)}, size: function () { retornar this.length}}), n.fn.andSelf = n.fn.addBack, "função"== typeof define && define.amd && define ("jquery", [], function () {return n}); var Nb = a.jQuery, Ob = a. $; return n.noConflict = function (b) {return a. $ === n && (a. $ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n}, b || (a.jQuery = a. $ = n), n});